Requires expression (since C++20)

   From cppreference.com
   < cpp | language

   C++
   Compiler support
   Freestanding and hosted
   Language
   Standard library
   Standard library headers
   Named requirements
   Feature test macros (C++20)
   Language support library
   Concepts library (C++20)
   Metaprogramming library (C++11)
   Diagnostics library
   General utilities library
   Strings library
   Containers library
   Iterators library
   Ranges library (C++20)
   Algorithms library
   Numerics library
   Localizations library
   Input/output library
   Filesystem library (C++17)
   Regular expressions library (C++11)
   Concurrency support library (C++11)
   Technical specifications
   Symbols index
   External libraries

   C++ language
   General topics
   Preprocessor
   Comments
   Keywords
   Escape sequences
   Flow control
   Conditional execution statements
   if
   switch
   Iteration statements (loops)
   for
   range-for (C++11)
   while
   do-while
   Jump statements
   continue - break
   goto - return
   Functions
   Function declaration
   Lambda function expression
   inline specifier
   Dynamic exception specifications (until C++17*)
   noexcept specifier (C++11)
   Exceptions
   throw-expression
   try block
   handler
   Namespaces
   Namespace declaration
   Namespace aliases
   Types
   Fundamental types
   Enumeration types
   Function types
   Class/struct types
   Union types
   Specifiers
   const/volatile
   decltype (C++11)
   auto (C++11)
   constexpr (C++11)
   consteval (C++20)
   constinit (C++20)
   Storage duration specifiers
   Initialization
   Default-initialization
   Value-initialization
   Zero-initialization
   Copy-initialization
   Direct-initialization
   Aggregate initialization
   List-initialization (C++11)
   Constant initialization
   Reference initialization
   Expressions
   Value categories
   Order of evaluation
   Operators
   Operator precedence
   Alternative representations
   Literals
   Boolean - Integer - Floating-point
   Character - String - nullptr (C++11)
   User-defined (C++11)
   Utilities
   Attributes (C++11)
   Types
   typedef declaration
   Type alias declaration (C++11)
   Casts
   Implicit conversions
   static_cast
   const_cast
   Explicit conversions
   dynamic_cast
   reinterpret_cast
   Memory allocation
   new expression
   delete expression
   Classes
   Class declaration
   Constructors
   this pointer
   Access specifiers
   friend specifier
   Class-specific function properties
   Virtual function
   override specifier (C++11)
   final specifier (C++11)
   explicit (C++11)
   static
   Special member functions
   Default constructor
   Copy constructor
   Move constructor (C++11)
   Copy assignment
   Move assignment (C++11)
   Destructor
   Templates
   Class template
   Function template
   Template specialization
   Parameter packs (C++11)
   Miscellaneous
   Inline assembly
   History of C++

   Declarations
   Overview
   Declaration syntax
   decl-specifier-seq
   Declarator
   Conflicting declarations
   Specifiers
   typedef
   inline
   virtual function specifier
   explicit function specifier
   friend
   constexpr
   (C++11)
   consteval
   (C++20)
   constinit
   (C++20)
   Storage class specifiers
   Translation-unit-local (C++20)
   class/struct
   union
   enum
   decltype
   (C++11)
   auto
   (C++11)
   alignas
   (C++11)
   constvolatile
   Pack indexing specifier (C++26)
   Elaborated type specifier
   Attributes (C++11)
   Declarators
   Reference
   Pointer
   Array
   Block declarations
   Simple-declaration
   ->Structured binding declaration (C++17)
   Alias declaration (C++11)
   Namespace alias definition
   using declaration
   using directive
   static_assert declaration (C++11)
   asm declaration
   Opaque enum declaration (C++11)
   Other declarations
   Namespace definition
   Function declaration
   Class template declaration
   Function template declaration
   Explicit template instantiation (C++11)
   Explicit template specialization
   Linkage specification
   Attribute declaration (C++11)
   Empty declaration

   Expressions
   General
   Value categories
   Order of evaluation
   Constant expressions
   Primary expressions
   Lambda expressions (C++11)
   Pack indexing expression (C++26)
   Potentially-evaluated expressions
   Literals
   Integer literals
   Floating-point literals
   Boolean literals
   Character literals
   Escape sequences
   String literals
   Null pointer literal (C++11)
   User-defined literal (C++11)
   Operators
   Assignment operators
   Increment and decrement
   Arithmetic operators
   Logical operators
   Comparison operators
   Member access operators
   Other operators
   new-expression
   delete-expression
   throw-expression
   alignof
   sizeof
   sizeof... (C++11)
   typeid
   noexcept (C++11)
   Fold expressions (C++17)
   Alternative representations of operators
   Precedence and associativity
   Operator overloading
   Default comparisons (C++20)
   Conversions
   Implicit conversions
   Explicit conversions
   Usual arithmetic conversions
   User-defined conversion
   const_cast
   static_cast
   dynamic_cast
   reinterpret_cast

   Templates
   Parameters and arguments
   Class templates
   Function templates
   Class member templates
   Variable templates (C++14)
   Template argument deduction
   Class template argument deduction (C++17)
   Explicit (full) specialization
   Partial specialization
   Dependent names
   Parameter packs (C++11)
      sizeof... (C++11)
      Fold expressions (C++17)
      Pack indexing (C++26)
   SFINAE
   Constraints and concepts (C++20)
   Requires expression (C++20)

   Yields a prvalue expression of type bool that describes the
   constraints.

Syntax

   requires { requirement-seq }                               (1)
   requires ( parameter-list¿(optional) ) { requirement-seq } (2)
   parameter-list  - a parameter list
   requirement-seq - sequence of requirements, each requirement is one of
   the following:
     * simple requirement
     * type requirement
     * compound requirement
     * nested requirement

Explanation

   Requirements may refer to the template parameters that are in scope, to
   the parameters of parameter-list, and to any other declarations that
   are visible from the enclosing context.

   The substitution of template arguments into a requires-expression used
   in a declaration of a templated entity may result in the formation of
   invalid types or expressions in its requirements, or the violation of
   semantic constraints of those requirements. In such cases, the
   requires-expression evaluates to false and does not cause the program
   to be ill-formed. The substitution and semantic constraint checking
   proceeds in lexical order and stops when a condition that determines
   the result of the requires-expression is encountered. If substitution
   (if any) and semantic constraint checking succeed, the
   requires-expression evaluates to true.

   If a substitution failure would occur in a requires-expression for
   every possible template argument, the program is ill-formed, no
   diagnostic required:
template<class T>
concept C = requires
{
    new int[-(int)sizeof(T)]; // invalid for every T: ill-formed, no diagnostic
required
};

   If a requires-expression contains invalid types or expressions in its
   requirements, and it does not appear within the declaration of a
   templated entity, then the program is ill-formed.

Local parameters

   A requires-expression can introduce local parameters using a parameter
   list. These parameters have no linkage, storage, or lifetime; they are
   only used as notation for the purpose of defining requirements.

   The type of each parameter is determined by the same way as determining
   the actual type of function parameters:
template<typename T>
concept C = requires(T p[2])
{
    (decltype(p))nullptr; // OK, p has type T*
};

   If any of the following conditions is satisfied, the program is
   ill-formed:
     * A local parameter has a default argument.
     * The parameter list terminate with an ellipsis.

template<typename T>
concept C1 = requires(T t = 0)  // Error: t has a default argument
{
    t;
};

template<typename T>
concept C2 = requires(T t, ...) // Error: terminates with an ellipsis
{
    t;
};

Requirements

Simple requirements

   A simple requirement is an arbitrary expression statement that does not
   start with the keyword requires. It asserts that the expression is
   valid. The expression is an unevaluated operand; only language
   correctness is checked.
template<typename T>
concept Addable = requires (T a, T b)
{
    a + b; // "the expression "a + b" is a valid expression that will compile"
};

template<class T, class U = T>
concept Swappable = requires(T&& t, U&& u)
{
    swap(std::forward<T>(t), std::forward<U>(u));
    swap(std::forward<U>(u), std::forward<T>(t));
};

   A requirement that starts with the keyword requires is always
   interpreted as a nested requirement. Thus a simple requirement cannot
   start with an unparenthesized requires-expression.

Type requirements

   A type requirement is the keyword typename followed by a type name,
   optionally qualified. The requirement is that the named type is valid:
   this can be used to verify that a certain named nested type exists, or
   that a class template specialization names a type, or that an alias
   template specialization names a type. A type requirement naming a class
   template specialization does not require the type to be complete.
template<typename T>
using Ref = T&;

template<typename T>
concept C = requires
{
    typename T::inner; // required nested member name
    typename S<T>;     // required class template specialization
    typename Ref<T>;   // required alias template substitution
};

template<class T, class U>
using CommonType = std::common_type_t<T, U>;

template<class T, class U>
concept Common = requires (T&& t, U&& u)
{
    typename CommonType<T, U>; // CommonType<T, U> is valid and names a type
    { CommonType<T, U>{std::forward<T>(t)} };
    { CommonType<T, U>{std::forward<U>(u)} };
};

Compound requirements

   A compound requirement has the form
   { expression } noexcept(optional) return-type-requirement¿(optional) ;
   return-type-requirement - -> type-constraint

   and asserts properties of the named expression. Substitution and
   semantic constraint checking proceeds in the following order:
   1) Template arguments (if any) are substituted into expression;
   2) If noexcept is used, expression must not be potentially throwing;
   3) If return-type-requirement is present, then:
   a) Template arguments are substituted into the
   return-type-requirement¿;
   b) decltype((expression)) must satisfy the constraint imposed by the
   type-constraint. Otherwise, the enclosing requires-expression is false.
template<typename T>
concept C2 = requires(T x)
{
    // the expression *x must be valid
    // AND the type T::inner must be valid
    // AND the result of *x must be convertible to T::inner
    {*x} -> std::convertible_to<typename T::inner>;

    // the expression x + 1 must be valid
    // AND std::same_as<decltype((x + 1)), int> must be satisfied
    // i.e., (x + 1) must be a prvalue of type int
    {x + 1} -> std::same_as<int>;

    // the expression x * 1 must be valid
    // AND its result must be convertible to T
    {x * 1} -> std::convertible_to<T>;
};

Nested requirements

   A nested requirement has the form
   requires constraint-expression ;

   It can be used to specify additional constraints in terms of local
   parameters. The constraint-expression must be satisfied by the
   substituted template arguments, if any. Substitution of template
   arguments into a nested requirement causes substitution into the
   constraint-expression only to the extent needed to determine whether
   the constraint-expression is satisfied.
template<class T>
concept Semiregular = DefaultConstructible<T> &&
    CopyConstructible<T> && CopyAssignable<T> && Destructible<T> &&
requires(T a, std::size_t n)
{
    requires Same<T*, decltype(&a)>; // nested: "Same<...> evaluates to true"
    { a.~T() } noexcept; // compound: "a.~T()" is a valid expression that doesn'
t throw
    requires Same<T*, decltype(new T)>; // nested: "Same<...> evaluates to true"
    requires Same<T*, decltype(new T[n])>; // nested
    { delete new T }; // compound
    { delete new T[n] }; // compound
};

Note

   The keyword requires is also used to introduce requires clauses.
template<typename T>
concept Addable = requires (T x) { x + x; }; // requires-expression

template<typename T> requires Addable<T> // requires-clause, not requires-expres
sion
T add(T a, T b) { return a + b; }

template<typename T>
    requires requires (T x) { x + x; } // ad-hoc constraint, note keyword used t
wice
T add(T a, T b) { return a + b; }

Keywords

   requires

Defect reports

   The following behavior-changing defect reports were applied
   retroactively to previously published C++ standards.
   DR Applied to Behavior as published Correct behavior
   CWG 2560 C++20 it was unclear whether parameter types are adjusted in
   requires-expressions also adjusted

See also

   Constraints and concepts(C++20) specifies the requirements on template
   arguments
   Retrieved from
   "https://en.cppreference.com/mwiki/index.php?title=cpp/language/require
   s&oldid=171746"

Navigation

     * Online version
     * Offline version retrieved 2024-06-10 08:17.

     * This page was last modified on 14 May 2024, at 02:32.
     * This page has been accessed 137,264 times.
