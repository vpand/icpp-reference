std::unique_lock<Mutex>::lock

   From cppreference.com
   < cpp | thread | unique lock

   C++
   Compiler support
   Freestanding and hosted
   Language
   Standard library
   Standard library headers
   Named requirements
   Feature test macros (C++20)
   Language support library
   Concepts library (C++20)
   Metaprogramming library (C++11)
   Diagnostics library
   General utilities library
   Strings library
   Containers library
   Iterators library
   Ranges library (C++20)
   Algorithms library
   Numerics library
   Localizations library
   Input/output library
   Filesystem library (C++17)
   Regular expressions library (C++11)
   Concurrency support library (C++11)
   Technical specifications
   Symbols index
   External libraries

   Concurrency support library
   Threads
   thread
   (C++11)
   jthread
   (C++20)
   stop_token
   (C++20)
   stop_source
   (C++20)
   stop_callback
   (C++20)
   hardware_destructive_interference_sizehardware_constructive_interferenc
   e_size
   (C++17)(C++17)
   this_thread namespace
   get_id
   (C++11)
   yield
   (C++11)
   sleep_for
   (C++11)
   sleep_until
   (C++11)
   Mutual exclusion
   mutex
   (C++11)
   recursive_mutex
   (C++11)
   shared_mutex
   (C++17)
   timed_mutex
   (C++11)
   recursive_timed_mutex
   (C++11)
   shared_timed_mutex
   (C++14)
   Generic lock management
   lock_guard
   (C++11)
   scoped_lock
   (C++17)
   unique_lock
   (C++11)
   shared_lock
   (C++14)
   defer_lock_ttry_to_lock_tadopt_lock_t
   (C++11)(C++11)(C++11)
   lock
   (C++11)
   try_lock
   (C++11)
   defer_locktry_to_lockadopt_lock
   (C++11)(C++11)(C++11)
   once_flag
   (C++11)
   call_once
   (C++11)
   Condition variables
   condition_variable
   (C++11)
   condition_variable_any
   (C++11)
   notify_all_at_thread_exit
   (C++11)
   cv_status
   (C++11)
   Semaphores
   counting_semaphorebinary_semaphore
   (C++20)(C++20)
   Latches and Barriers
   latch
   (C++20)
   barrier
   (C++20)
   Futures
   promise
   (C++11)
   future
   (C++11)
   shared_future
   (C++11)
   packaged_task
   (C++11)
   async
   (C++11)
   launch
   (C++11)
   future_status
   (C++11)
   future_error
   (C++11)
   future_category
   (C++11)
   future_errc
   (C++11)
   Safe Reclamation
   rcu_obj_base
   (C++26)
   rcu_domain
   (C++26)
   rcu_default_domain
   (C++26)
   rcu_synchronize
   (C++26)
   rcu_barrier
   (C++26)
   rcu_retire
   (C++26)
   Hazard Pointers
   hazard_pointer_obj_base
   (C++26)
   hazard_pointer
   (C++26)
   make_hazard_pointer
   (C++26)
   Atomic types
   atomic
   (C++11)
   atomic_ref
   (C++20)
   atomic_flag
   (C++11)
   Initialization of atomic types
   atomic_init
   (C++11)(deprecated in C++20)
   ATOMIC_VAR_INIT
   (C++11)(deprecated in C++20)
   ATOMIC_FLAG_INIT
   (C++11)
   Memory ordering
   memory_order
   (C++11)
   kill_dependency
   (C++11)
   atomic_thread_fence
   (C++11)
   atomic_signal_fence
   (C++11)
   Free functions for atomic operations
   atomic_storeatomic_store_explicit
   (C++11)(C++11)
   atomic_loadatomic_load_explicit
   (C++11)(C++11)
   atomic_exchangeatomic_exchange_explicit
   (C++11)(C++11)
   atomic_compare_exchange_weakatomic_compare_exchange_weak_explicitatomic
   _compare_exchange_strongatomic_compare_exchange_strong_explicit
   (C++11)(C++11)(C++11)(C++11)
   atomic_fetch_addatomic_fetch_add_explicit
   (C++11)(C++11)
   atomic_fetch_subatomic_fetch_sub_explicit
   (C++11)(C++11)
   atomic_fetch_andatomic_fetch_and_explicit
   (C++11)(C++11)
   atomic_fetch_oratomic_fetch_or_explicit
   (C++11)(C++11)
   atomic_fetch_xoratomic_fetch_xor_explicit
   (C++11)(C++11)
   atomic_fetch_maxatomic_fetch_max_explicit
   (C++26)(C++26)
   atomic_fetch_minatomic_fetch_min_explicit
   (C++26)(C++26)
   atomic_is_lock_free
   (C++11)
   atomic_waitatomic_wait_explicit
   (C++20)(C++20)
   atomic_notify_one
   (C++20)
   atomic_notify_all
   (C++20)
   Free functions for atomic flags
   atomic_flag_test_and_setatomic_flag_test_and_set_explicit
   (C++11)(C++11)
   atomic_flag_clearatomic_flag_clear_explicit
   (C++11)(C++11)
   atomic_flag_testatomic_flag_test_explicit
   (C++20)(C++20)
   atomic_flag_waitatomic_flag_wait_explicit
   (C++20)(C++20)
   atomic_flag_notify_one
   (C++20)
   atomic_flag_notify_all
   (C++20)

   std::unique_lock
   Member functions
   unique_lock::unique_lock
   unique_lock::~unique_lock
   unique_lock::operator=
   Locking
   unique_lock::lock
   unique_lock::try_lock
   unique_lock::try_lock_for
   unique_lock::try_lock_until
   unique_lock::unlock
   Modifiers
   unique_lock::swap
   unique_lock::release
   Observers
   unique_lock::mutex
   unique_lock::owns_lock
   unique_lock::operator bool
   Non-member functions
   swap(std::unique_lock)

   void lock();
               (since C++11)

   Locks (i.e., takes ownership of) the associated mutex. Effectively
   calls mutex()->lock().

Parameters

   (none)

Return value

   (none)

Exceptions

     * Any exceptions thrown by mutex()->lock().

     * If there is no associated mutex, std::system_error with an error
       code of std::errc::operation_not_permitted.

     * If the mutex is already locked by this unique_lock (in other words,
       owns_lock is true), std::system_error with an error code of
       std::errc::resource_deadlock_would_occur.

Example

   The following example uses lock to re-acquire a mutex that was
   unlocked.
   Run this code
#include <chrono>
#include <iostream>
#include <mutex>
#include <thread>
#include <vector>

int main()
{
    int counter = 0;
    std::mutex counter_mutex;
    std::vector<std::thread> threads;

    auto worker_task = [&](int id)
    {
        std::unique_lock<std::mutex> lock(counter_mutex);
        ++counter;
        std::cout << id << ", initial counter: " << counter << '\n';
        lock.unlock();

        // don't hold the lock while we simulate an expensive operation
        std::this_thread::sleep_for(std::chrono::seconds(1));

        lock.lock();
        ++counter;
        std::cout << id << ", final counter: " << counter << '\n';
    };

    for (int i = 0; i < 10; ++i)
        threads.emplace_back(worker_task, i);

    for (auto& thread : threads)
        thread.join();
}

   Possible output:
0, initial counter: 1
1, initial counter: 2
2, initial counter: 3
3, initial counter: 4
4, initial counter: 5
5, initial counter: 6
6, initial counter: 7
7, initial counter: 8
8, initial counter: 9
9, initial counter: 10
6, final counter: 11
3, final counter: 12
4, final counter: 13
2, final counter: 14
5, final counter: 15
0, final counter: 16
1, final counter: 17
7, final counter: 18
9, final counter: 19
8, final counter: 20

See also

   try_lock
   tries to lock (i.e., takes ownership of) the associated mutex without
   blocking
   (public member function)
   unlock
   unlocks (i.e., releases ownership of) the associated mutex
   (public member function)
   Retrieved from
   "https://en.cppreference.com/mwiki/index.php?title=cpp/thread/unique_lo
   ck/lock&oldid=161292"

Navigation

     * Online version
     * Offline version retrieved 2024-06-10 08:17.

     * This page was last modified on 24 October 2023, at 11:13.
     * This page has been accessed 116,778 times.
