std::atomic_thread_fence

   From cppreference.com
   < cpp | atomic

   C++
   Compiler support
   Freestanding and hosted
   Language
   Standard library
   Standard library headers
   Named requirements
   Feature test macros (C++20)
   Language support library
   Concepts library (C++20)
   Metaprogramming library (C++11)
   Diagnostics library
   General utilities library
   Strings library
   Containers library
   Iterators library
   Ranges library (C++20)
   Algorithms library
   Numerics library
   Localizations library
   Input/output library
   Filesystem library (C++17)
   Regular expressions library (C++11)
   Concurrency support library (C++11)
   Technical specifications
   Symbols index
   External libraries

   Concurrency support library
   Threads
   thread
   (C++11)
   jthread
   (C++20)
   stop_token
   (C++20)
   stop_source
   (C++20)
   stop_callback
   (C++20)
   hardware_destructive_interference_sizehardware_constructive_interferenc
   e_size
   (C++17)(C++17)
   this_thread namespace
   get_id
   (C++11)
   yield
   (C++11)
   sleep_for
   (C++11)
   sleep_until
   (C++11)
   Mutual exclusion
   mutex
   (C++11)
   recursive_mutex
   (C++11)
   shared_mutex
   (C++17)
   timed_mutex
   (C++11)
   recursive_timed_mutex
   (C++11)
   shared_timed_mutex
   (C++14)
   Generic lock management
   lock_guard
   (C++11)
   scoped_lock
   (C++17)
   unique_lock
   (C++11)
   shared_lock
   (C++14)
   defer_lock_ttry_to_lock_tadopt_lock_t
   (C++11)(C++11)(C++11)
   lock
   (C++11)
   try_lock
   (C++11)
   defer_locktry_to_lockadopt_lock
   (C++11)(C++11)(C++11)
   once_flag
   (C++11)
   call_once
   (C++11)
   Condition variables
   condition_variable
   (C++11)
   condition_variable_any
   (C++11)
   notify_all_at_thread_exit
   (C++11)
   cv_status
   (C++11)
   Semaphores
   counting_semaphorebinary_semaphore
   (C++20)(C++20)
   Latches and Barriers
   latch
   (C++20)
   barrier
   (C++20)
   Futures
   promise
   (C++11)
   future
   (C++11)
   shared_future
   (C++11)
   packaged_task
   (C++11)
   async
   (C++11)
   launch
   (C++11)
   future_status
   (C++11)
   future_error
   (C++11)
   future_category
   (C++11)
   future_errc
   (C++11)
   Safe Reclamation
   rcu_obj_base
   (C++26)
   rcu_domain
   (C++26)
   rcu_default_domain
   (C++26)
   rcu_synchronize
   (C++26)
   rcu_barrier
   (C++26)
   rcu_retire
   (C++26)
   Hazard Pointers
   hazard_pointer_obj_base
   (C++26)
   hazard_pointer
   (C++26)
   make_hazard_pointer
   (C++26)
   Atomic types
   atomic
   (C++11)
   atomic_ref
   (C++20)
   atomic_flag
   (C++11)
   Initialization of atomic types
   atomic_init
   (C++11)(deprecated in C++20)
   ATOMIC_VAR_INIT
   (C++11)(deprecated in C++20)
   ATOMIC_FLAG_INIT
   (C++11)
   Memory ordering
   memory_order
   (C++11)
   kill_dependency
   (C++11)
   atomic_thread_fence
   (C++11)
   atomic_signal_fence
   (C++11)
   Free functions for atomic operations
   atomic_storeatomic_store_explicit
   (C++11)(C++11)
   atomic_loadatomic_load_explicit
   (C++11)(C++11)
   atomic_exchangeatomic_exchange_explicit
   (C++11)(C++11)
   atomic_compare_exchange_weakatomic_compare_exchange_weak_explicitatomic
   _compare_exchange_strongatomic_compare_exchange_strong_explicit
   (C++11)(C++11)(C++11)(C++11)
   atomic_fetch_addatomic_fetch_add_explicit
   (C++11)(C++11)
   atomic_fetch_subatomic_fetch_sub_explicit
   (C++11)(C++11)
   atomic_fetch_andatomic_fetch_and_explicit
   (C++11)(C++11)
   atomic_fetch_oratomic_fetch_or_explicit
   (C++11)(C++11)
   atomic_fetch_xoratomic_fetch_xor_explicit
   (C++11)(C++11)
   atomic_fetch_maxatomic_fetch_max_explicit
   (C++26)(C++26)
   atomic_fetch_minatomic_fetch_min_explicit
   (C++26)(C++26)
   atomic_is_lock_free
   (C++11)
   atomic_waitatomic_wait_explicit
   (C++20)(C++20)
   atomic_notify_one
   (C++20)
   atomic_notify_all
   (C++20)
   Free functions for atomic flags
   atomic_flag_test_and_setatomic_flag_test_and_set_explicit
   (C++11)(C++11)
   atomic_flag_clearatomic_flag_clear_explicit
   (C++11)(C++11)
   atomic_flag_testatomic_flag_test_explicit
   (C++20)(C++20)
   atomic_flag_waitatomic_flag_wait_explicit
   (C++20)(C++20)
   atomic_flag_notify_one
   (C++20)
   atomic_flag_notify_all
   (C++20)

   Defined in header <atomic>
   extern "C" void atomic_thread_fence( std::memory_order order )
   noexcept;
                                                                 (since C++11)

   Establishes memory synchronization ordering of non-atomic and relaxed
   atomic accesses, as instructed by order, without an associated atomic
   operation. Note however, that at least one atomic operation is required
   to set up the synchronization, as described below.

Fence-atomic synchronization

   A release fence F in thread A synchronizes-with atomic acquire
   operation Y in thread B, if
     * there exists an atomic store X (with any memory order),
     * Y reads the value written by X (or the value would be written by
       release sequence headed by X if X were a release operation),
     * F is sequenced-before X in thread A.

   In this case, all non-atomic and relaxed atomic stores that are
   sequenced-before F in thread A will happen-before all non-atomic and
   relaxed atomic loads from the same locations made in thread B after Y.

Atomic-fence synchronization

   An atomic release operation X in thread A synchronizes-with an acquire
   fence F in thread B, if
     * there exists an atomic read Y (with any memory order),
     * Y reads the value written by X (or by the release sequence headed
       by X),
     * Y is sequenced-before F in thread B.

   In this case, all non-atomic and relaxed atomic stores that are
   sequenced-before X in thread A will happen-before all non-atomic and
   relaxed atomic loads from the same locations made in thread B after F.

Fence-fence synchronization

   A release fence FA in thread A synchronizes-with an acquire fence FB in
   thread B, if
     * there exists an atomic object M,
     * there exists an atomic write X (with any memory order) that
       modifies M in thread A,
     * FA is sequenced-before X in thread A,
     * there exists an atomic read Y (with any memory order) in thread B,
     * Y reads the value written by X (or the value would be written by
       release sequence headed by X if X were a release operation),
     * Y is sequenced-before FB in thread B.

   In this case, all non-atomic and relaxed atomic stores that are
   sequenced-before FA in thread A will happen-before all non-atomic and
   relaxed atomic loads from the same locations made in thread B after FB.

Parameters

   order - the memory ordering executed by this fence

Return value

   (none)

Notes

   On x86 (including x86-64), atomic_thread_fence functions issue no CPU
   instructions and only affect compile-time code motion, except for
   std::atomic_thread_fence(std::memory_order::seq_cst).

   atomic_thread_fence imposes stronger synchronization constraints than
   an atomic store operation with the same std::memory_order. While an
   atomic store-release operation prevents all preceding reads and writes
   from moving past the store-release, an atomic_thread_fence with
   memory_order_release ordering prevents all preceding reads and writes
   from moving past all subsequent stores.

   Fence-fence synchronization can be used to add synchronization to a
   sequence of several relaxed atomic operations, for example:
// Global
std::string computation(int);
void print(std::string);

std::atomic<int> arr[3] = {-1, -1, -1};
std::string data[1000]; //non-atomic data

// Thread A, compute 3 values.
void ThreadA(int v0, int v1, int v2)
{
//  assert(0 <= v0, v1, v2 < 1000);
    data[v0] = computation(v0);
    data[v1] = computation(v1);
    data[v2] = computation(v2);
    std::atomic_thread_fence(std::memory_order_release);
    std::atomic_store_explicit(&arr[0], v0, std::memory_order_relaxed);
    std::atomic_store_explicit(&arr[1], v1, std::memory_order_relaxed);
    std::atomic_store_explicit(&arr[2], v2, std::memory_order_relaxed);
}

// Thread B, prints between 0 and 3 values already computed.
void ThreadB()
{
    int v0 = std::atomic_load_explicit(&arr[0], std::memory_order_relaxed);
    int v1 = std::atomic_load_explicit(&arr[1], std::memory_order_relaxed);
    int v2 = std::atomic_load_explicit(&arr[2], std::memory_order_relaxed);
    std::atomic_thread_fence(std::memory_order_acquire);
//  v0, v1, v2 might turn out to be -1, some or all of them.
//  Otherwise it is safe to read the non-atomic data because of the fences:
    if (v0 != -1)
        print(data[v0]);
    if (v1 != -1)
        print(data[v1]);
    if (v2 != -1)
        print(data[v2]);
}

Example

   Scan an array of mailboxes, and process only the ones intended for us,
   without unnecessary synchronization. This example uses atomic-fence
   synchronization.
const int num_mailboxes = 32;
std::atomic<int> mailbox_receiver[num_mailboxes];
std::string mailbox_data[num_mailboxes];

// The writer threads update non-atomic shared data
// and then update mailbox_receiver[i] as follows:
mailbox_data[i] = ...;
std::atomic_store_explicit(&mailbox_receiver[i], receiver_id, std::memory_order_
release);

// Reader thread needs to check all mailbox[i], but only needs to sync with one.
for (int i = 0; i < num_mailboxes; ++i)
    if (std::atomic_load_explicit(&mailbox_receiver[i],
        std::memory_order_relaxed) == my_id)
    {
        // synchronize with just one writer
        std::atomic_thread_fence(std::memory_order_acquire);
        // guaranteed to observe everything done in the writer thread
        // before the atomic_store_explicit()
        do_work(mailbox_data[i]);
    }

See also

   memory_order
   (C++11)
   defines memory ordering constraints for the given atomic operation
   (enum)
   atomic_signal_fence
   (C++11)
   fence between a thread and a signal handler executed in the same thread
   (function)
   Retrieved from
   "https://en.cppreference.com/mwiki/index.php?title=cpp/atomic/atomic_th
   read_fence&oldid=157779"

Navigation

     * Online version
     * Offline version retrieved 2024-06-10 08:17.

     * This page was last modified on 3 September 2023, at 11:18.
     * This page has been accessed 230,972 times.
