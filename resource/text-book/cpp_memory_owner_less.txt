std::owner_less

   From cppreference.com
   < cpp | memory

   C++
   Compiler support
   Freestanding and hosted
   Language
   Standard library
   Standard library headers
   Named requirements
   Feature test macros (C++20)
   Language support library
   Concepts library (C++20)
   Metaprogramming library (C++11)
   Diagnostics library
   General utilities library
   Strings library
   Containers library
   Iterators library
   Ranges library (C++20)
   Algorithms library
   Numerics library
   Localizations library
   Input/output library
   Filesystem library (C++17)
   Regular expressions library (C++11)
   Concurrency support library (C++11)
   Technical specifications
   Symbols index
   External libraries

   Utilities library
   Language support
   Type support (basic types, RTTI)
   Library feature-test macros (C++20)
   Dynamic memory management
   Program utilities
   Coroutine support (C++20)
   Variadic functions
   is_constant_evaluated
   (C++20)
   is_within_lifetime
   (C++26)
   initializer_list
   (C++11)
   source_location
   (C++20)
   Debugging support
   is_debugger_present
   (C++26)
   breakpoint_if_debugging
   (C++26)
   breakpoint
   (C++26)
   Three-way comparison
   three_way_comparablethree_way_comparable_with
   (C++20)(C++20)
   strong_ordering
   (C++20)
   weak_ordering
   (C++20)
   partial_ordering
   (C++20)
   common_comparison_category
   (C++20)
   compare_three_way_result
   (C++20)
   compare_three_way
   (C++20)
   strong_order
   (C++20)
   weak_order
   (C++20)
   partial_order
   (C++20)
   compare_strong_order_fallback
   (C++20)
   compare_weak_order_fallback
   (C++20)
   compare_partial_order_fallback
   (C++20)
   is_eqis_ltis_lteq
   (C++20)(C++20)(C++20)
   is_neqis_gtis_gteq
   (C++20)(C++20)(C++20)
   General utilities
   Date and time
   Function objects
   Formatting library (C++20)
   bitset
   hash
   (C++11)
   Relational operators (deprecated in C++20)
   rel_ops::operator!=rel_ops::operator>

   rel_ops::operator<=rel_ops::operator>=
   Integer comparison functions
   cmp_equalcmp_lesscmp_less_than
   (C++20)(C++20)(C++20)
   cmp_not_equalcmp_greatercmp_greater_than
   (C++20)(C++20)(C++20)
   in_range
   (C++20)
   Swap and type operations
   swap
   ranges::swap
   (C++20)
   exchange
   (C++14)
   declval
   (C++11)
   to_underlying
   (C++23)
   forward
   (C++11)
   forward_like
   (C++23)
   move
   (C++11)
   move_if_noexcept
   (C++11)
   as_const
   (C++17)
   Common vocabulary types
   pair
   tuple
   (C++11)
   optional
   (C++17)
   any
   (C++17)
   variant
   (C++17)
   tuple_size
   (C++11)
   tuple_element
   (C++11)
   apply
   (C++17)
   make_from_tuple
   (C++17)
   expected
   (C++23)
   Elementary string conversions
   to_chars
   (C++17)
   from_chars
   (C++17)
   chars_format
   (C++17)
   to_chars_result
   (C++17)
   from_chars_result
   (C++17)

   Dynamic memory management
   Uninitialized memory algorithms
   uninitialized_copy
   uninitialized_fill
   uninitialized_move
   (C++17)
   uninitialized_default_construct
   (C++17)
   uninitialized_value_construct
   (C++17)
   destroy
   (C++17)
   destroy_at
   (C++17)
   voidify
   (C++20)
   uninitialized_copy_n
   (C++11)
   uninitialized_fill_n
   uninitialized_move_n
   (C++17)
   uninitialized_default_construct_n
   (C++17)
   uninitialized_value_construct_n
   (C++17)
   destroy_n
   (C++17)
   construct_at
   (C++20)
   Constrained uninitialized memory algorithms
   ranges::uninitialized_copy
   (C++20)
   ranges::uninitialized_fill
   (C++20)
   ranges::uninitialized_move
   (C++20)
   ranges::construct_at
   (C++20)
   ranges::destroy
   (C++20)
   ranges::destroy_n
   (C++20)
   ranges::destroy_at
   (C++20)
   ranges::uninitialized_copy_n
   (C++20)
   ranges::uninitialized_fill_n
   (C++20)
   ranges::uninitialized_move_n
   (C++20)
   ranges::uninitialized_default_construct
   (C++20)
   ranges::uninitialized_value_construct
   (C++20)
   ranges::uninitialized_default_construct_n
   (C++20)
   ranges::uninitialized_value_construct_n
   (C++20)
   Allocators
   allocator
   allocator_traits
   (C++11)
   allocation_result
   (C++23)
   allocator_arg
   (C++11)
   uses_allocator
   (C++11)
   uses_allocator_construction_args
   (C++20)
   make_obj_using_allocator
   (C++20)
   uninitialized_construct_using_allocator
   (C++20)
   scoped_allocator_adaptor
   (C++11)
   pmr::polymorphic_allocator
   (C++17)
   Memory resources
   pmr::memory_resource
   (C++17)
   pmr::get_default_resource
   (C++17)
   pmr::set_default_resource
   (C++17)
   pmr::new_delete_resource
   (C++17)
   pmr::null_memory_resource
   (C++17)
   pmr::synchronized_pool_resource
   (C++17)
   pmr::unsynchronized_pool_resource
   (C++17)
   pmr::monotonic_buffer_resource
   (C++17)
   pmr::pool_options
   (C++17)
   Garbage collection support
   declare_reachable
   (C++11)(until C++23)
   undeclare_reachable
   (C++11)(until C++23)
   declare_no_pointers
   (C++11)(until C++23)
   undeclare_no_pointers
   (C++11)(until C++23)
   pointer_safety
   (C++11)(until C++23)
   get_pointer_safety
   (C++11)(until C++23)
   Uninitialized storage
   raw_storage_iterator
   (until C++20*)
   get_temporary_buffer
   (until C++20*)
   return_temporary_buffer
   (until C++20*)
   Explicit lifetime management
   start_lifetime_asstart_lifetime_as_array
   (C++23)(C++23)
   Smart pointers
   unique_ptr
   (C++11)
   shared_ptr
   (C++11)
   weak_ptr
   (C++11)
   auto_ptr
   (until C++17*)
   owner_less
   (C++11)
   owner_less<void>
   (C++17)
   owner_hash
   (C++26)
   owner_equal
   (C++26)
   enable_shared_from_this
   (C++11)
   bad_weak_ptr
   (C++11)
   default_delete
   (C++11)
   out_ptr_t
   (C++23)
   inout_ptr_t
   (C++23)
   Low level memory
   management
   operator new
   operator new[]
   operator delete
   operator delete[]
   get_new_handler
   set_new_handler
   launder
   (C++17)
   bad_alloc
   bad_array_new_length
   nothrow_t
   align_val_t
   destroying_delete_t
   new_handler
   nothrow
   Miscellaneous
   pointer_traits
   (C++11)
   to_address
   (C++20)
   addressof
   (C++11)
   align
   (C++11)
   assume_aligned
   (C++20)
   C Library
   malloc
   calloc
   realloc

   aligned_alloc
   (C++17)
   free

   Defined in header <memory>
                             (1)
   template< class T >
   struct owner_less; /* undefined */
   (since C++11)
   (until C++17)
   template< class T = void >
   struct owner_less; /* undefined */
                                           (since C++17)
   template< class T >
   struct owner_less<std::shared_ptr<T>>;
   (2)                       (since C++11)
   template< class T >
   struct owner_less<std::weak_ptr<T>>;
   (3)                       (since C++11)
   template<>
   struct owner_less<void>;
   (4)                       (since C++17)

   This function object provides owner-based (as opposed to value-based)
   mixed-type ordering of both std::weak_ptr and std::shared_ptr. The
   order is such that two smart pointers compare equivalent only if they
   are both empty or if they share ownership, even if the values of the
   raw pointers obtained by get() are different (e.g. because they point
   at different subobjects within the same object).
   1) Owner-based mixed-type ordering is not provided for types other than
   std::shared_ptr and std::weak_ptr.
   2) The owner-based mixed-type ordering of std::shared_ptr.
   It is the preferred comparison predicate when building associative
   containers with std::shared_ptr as keys, that is,
   std::map<std::shared_ptr<T>, U, std::owner_less<std::shared_ptr<T>>>.
   3) The owner-based mixed-type ordering of std::weak_ptr.
   It is the preferred comparison predicate when building associative
   containers with std::weak_ptr as keys, that is,
   std::map<std::weak_ptr<T>, U, std::owner_less<std::weak_ptr<T>>>.
   4) The void specialization deduces the parameter types from the
   arguments.

   The default operator< is not defined for weak pointers, and may wrongly
   consider two shared pointers for the same object non-equivalent (see
   std::shared_ptr::owner_before).

Specializations

   The standard library provides a specialization of std::owner_less when
   T is not specified. In this case, the parameter types are deduced from
   the arguments (each of which must still be either a std::shared_ptr or
   a std::weak_ptr).
   owner_less<void>
   function object providing mixed-type owner-based ordering of shared and
   weak pointers, regardless of the type of the pointee
   (class template specialization)
   (since C++17)

Nested types

   Nested type Definition
   result_type (deprecated in C++17) (2,3) bool
   first_argument_type (deprecated in C++17) (2) std::shared_ptr<T>
   (3) std::weak_ptr<T>
   second_argument_type (deprecated in C++17) (2) std::shared_ptr<T>
   (3) std::weak_ptr<T>
   (until C++20)

Member functions

   operator()
   compares its arguments using owner-based semantics
   (function)

std::owner_less::operator()

   member only of specialization (2)
   bool operator()( const std::shared_ptr<T>& lhs,
                    const std::shared_ptr<T>& rhs ) const noexcept;
                                                  (since C++11)
   member only of specialization (3)
   bool operator()( const std::weak_ptr<T>& lhs,
                    const std::weak_ptr<T>& rhs ) const noexcept;
                                                  (since C++11)
   member of both template specializations
   bool operator()( const std::shared_ptr<T>& lhs,
                    const std::weak_ptr<T>& rhs ) const noexcept;
                                                  (since C++11)
   bool operator()( const std::weak_ptr<T>& lhs,
                    const std::shared_ptr<T>& rhs ) const noexcept;
                                                  (since C++11)

   Compares lhs and rhs using owner-based semantics. Effectively calls
   lhs.owner_before(rhs).

   The ordering is strict weak ordering relation.

   lhs and rhs are equivalent only if they are both empty or share
   ownership.

Parameters

   lhs, rhs - shared-ownership pointers to compare

Return value

   true if lhs is less than rhs as determined by the owner-based ordering,
   false otherwise.

Defect reports

   The following behavior-changing defect reports were applied
   retroactively to previously published C++ standards.
   DR Applied to Behavior as published Correct behavior
   LWG 2873 C++11 operator() was not required to be noexcept required to
   be noexcept

See also

   owner_before
   provides owner-based ordering of shared pointers
   (public member function of std::shared_ptr<T>)
   owner_before
   provides owner-based ordering of weak pointers
   (public member function of std::weak_ptr<T>)
   Retrieved from
   "https://en.cppreference.com/mwiki/index.php?title=cpp/memory/owner_les
   s&oldid=164269"

Navigation

     * Online version
     * Offline version retrieved 2024-06-10 08:17.

     * This page was last modified on 29 November 2023, at 00:32.
     * This page has been accessed 104,274 times.
