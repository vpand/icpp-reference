alignas specifier (since C++11)

   From cppreference.com
   < cpp | language

   C++
   Compiler support
   Freestanding and hosted
   Language
   Standard library
   Standard library headers
   Named requirements
   Feature test macros (C++20)
   Language support library
   Concepts library (C++20)
   Metaprogramming library (C++11)
   Diagnostics library
   General utilities library
   Strings library
   Containers library
   Iterators library
   Ranges library (C++20)
   Algorithms library
   Numerics library
   Localizations library
   Input/output library
   Filesystem library (C++17)
   Regular expressions library (C++11)
   Concurrency support library (C++11)
   Technical specifications
   Symbols index
   External libraries

   C++ language
   General topics
   Preprocessor
   Comments
   Keywords
   Escape sequences
   Flow control
   Conditional execution statements
   if
   switch
   Iteration statements (loops)
   for
   range-for (C++11)
   while
   do-while
   Jump statements
   continue - break
   goto - return
   Functions
   Function declaration
   Lambda function expression
   inline specifier
   Dynamic exception specifications (until C++17*)
   noexcept specifier (C++11)
   Exceptions
   throw-expression
   try block
   handler
   Namespaces
   Namespace declaration
   Namespace aliases
   Types
   Fundamental types
   Enumeration types
   Function types
   Class/struct types
   Union types
   Specifiers
   const/volatile
   decltype (C++11)
   auto (C++11)
   constexpr (C++11)
   consteval (C++20)
   constinit (C++20)
   Storage duration specifiers
   Initialization
   Default-initialization
   Value-initialization
   Zero-initialization
   Copy-initialization
   Direct-initialization
   Aggregate initialization
   List-initialization (C++11)
   Constant initialization
   Reference initialization
   Expressions
   Value categories
   Order of evaluation
   Operators
   Operator precedence
   Alternative representations
   Literals
   Boolean - Integer - Floating-point
   Character - String - nullptr (C++11)
   User-defined (C++11)
   Utilities
   Attributes (C++11)
   Types
   typedef declaration
   Type alias declaration (C++11)
   Casts
   Implicit conversions
   static_cast
   const_cast
   Explicit conversions
   dynamic_cast
   reinterpret_cast
   Memory allocation
   new expression
   delete expression
   Classes
   Class declaration
   Constructors
   this pointer
   Access specifiers
   friend specifier
   Class-specific function properties
   Virtual function
   override specifier (C++11)
   final specifier (C++11)
   explicit (C++11)
   static
   Special member functions
   Default constructor
   Copy constructor
   Move constructor (C++11)
   Copy assignment
   Move assignment (C++11)
   Destructor
   Templates
   Class template
   Function template
   Template specialization
   Parameter packs (C++11)
   Miscellaneous
   Inline assembly
   History of C++

   Declarations
   Overview
   Declaration syntax
   decl-specifier-seq
   Declarator
   Conflicting declarations
   Specifiers
   typedef
   inline
   virtual function specifier
   explicit function specifier
   friend
   constexpr
   (C++11)
   consteval
   (C++20)
   constinit
   (C++20)
   Storage class specifiers
   Translation-unit-local (C++20)
   class/struct
   union
   enum
   decltype
   (C++11)
   auto
   (C++11)
   alignas
   (C++11)
   constvolatile
   Pack indexing specifier (C++26)
   Elaborated type specifier
   Attributes (C++11)
   Declarators
   Reference
   Pointer
   Array
   Block declarations
   Simple-declaration
   ->Structured binding declaration (C++17)
   Alias declaration (C++11)
   Namespace alias definition
   using declaration
   using directive
   static_assert declaration (C++11)
   asm declaration
   Opaque enum declaration (C++11)
   Other declarations
   Namespace definition
   Function declaration
   Class template declaration
   Function template declaration
   Explicit template instantiation (C++11)
   Explicit template specialization
   Linkage specification
   Attribute declaration (C++11)
   Empty declaration

   Specifies the alignment requirement of a type or an object.

Syntax

   alignas( expression )
   alignas( type-id )
   alignas( pack ... )
   1) expression must be an integral constant expression that evaluates to
   zero, or to a valid value for an alignment or extended alignment.
   2) Equivalent to alignas(alignof( type-id )).
   3) Equivalent to multiple alignas specifiers applied to the same
   declaration, one for each member of the parameter pack, which can be
   either type or non-type parameter pack.

Explanation

   The alignas specifier may be applied to:
     * the declaration or definition of a class;
     * the declaration of a non-bitfield class data member;
     * the declaration of a variable, except that it cannot be applied to
       the following:
          + a function parameter;
          + the exception parameter of a catch clause.

   The object or the type declared by such a declaration will have its
   alignment requirement equal to the strictest (largest) non-zero
   expression of all alignas specifiers used in the declaration, unless it
   would weaken the natural alignment of the type.

   If the strictest (largest) alignas on a declaration is weaker than the
   alignment it would have without any alignas specifiers (that is, weaker
   than its natural alignment or weaker than alignas on another
   declaration of the same object or type), the program is ill-formed:
struct alignas(8) S {};
struct alignas(1) U { S s; }; // error: alignment of U would have been 8 without
 alignas(1)

   Invalid non-zero alignments, such as alignas(3) are ill-formed.

   Valid non-zero alignments that are weaker than another alignas on the
   same declaration are ignored.

   alignas(0) is always ignored.

Notes

   As of the ISO C11 standard, the C language has the _Alignas keyword and
   defines alignas as a preprocessor macro expanding to the keyword in the
   header <stdalign.h>.

   In C++, this is a keyword, and

   the headers <stdalign.h> and <cstdalign> do not define such macro. They
   do, however, define the macro constant __alignas_is_defined.
   (until C++20)

   the header <stdalign.h> does not define such macro. It does, however,
   define the macro constant __alignas_is_defined.
   (since C++20)

Keywords

   alignas

Example

   Run this code
#include <iostream>

// Every object of type struct_float will be aligned
// to alignof(float) boundary (usually 4):
struct alignas(float) struct_float
{
    // your definition here
};

// Every object of type sse_t will be aligned to 32-byte boundary:
struct alignas(32) sse_t
{
    float sse_data[4];
};

// The array "cacheline" will be aligned to 64-byte boundary:
using cacheline_t = alignas(64) char[64];
cacheline_t cacheline;

int main()
{
    struct default_aligned
    {
        float data[4];
    } a, b, c;
    sse_t x, y, z;

    std::cout
        << "alignof(struct_float) = " << alignof(struct_float) << '\n'
        << "sizeof(sse_t) = " << sizeof(sse_t) << '\n'
        << "alignof(sse_t) = " << alignof(sse_t) << '\n'
        << "alignof(cacheline_t) = " << alignof(cacheline_t) << '\n'
        << "alignof(cacheline) = " << alignof(decltype(cacheline)) << '\n'
        << std::hex << std::showbase
        << "&a: " << &a << "\n"
           "&b: " << &b << "\n"
           "&c: " << &c << "\n"
           "&x: " << &x << "\n"
           "&y: " << &y << "\n"
           "&z: " << &z << '\n';
}

   Possible output:
alignof(struct_float) = 4
sizeof(sse_t) = 32
alignof(sse_t) = 32
alignof(cacheline_t) = 64
alignof(cacheline) = 64
&a: 0x7fffcec89930
&b: 0x7fffcec89940
&c: 0x7fffcec89950
&x: 0x7fffcec89960
&y: 0x7fffcec89980
&z: 0x7fffcec899a0

Defect reports

   The following behavior-changing defect reports were applied
   retroactively to previously published C++ standards.
   DR Applied to Behavior as published Correct behavior
   CWG 1437 C++11 alignas could be used in alias declarations prohibited
   CWG 2354 C++11 alignas could be applied to the declaration of an
   enumeration prohibited

See also

   alignof operator(C++11) queries alignment requirements of a type
   alignment_of
   (C++11)
   obtains the type's alignment requirements
   (class template)
   Retrieved from
   "https://en.cppreference.com/mwiki/index.php?title=cpp/language/alignas
   &oldid=168765"

Navigation

     * Online version
     * Offline version retrieved 2024-06-10 08:17.

     * This page was last modified on 17 January 2024, at 14:52.
     * This page has been accessed 543,776 times.
