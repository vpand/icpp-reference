std::unique_lock<Mutex>::unique_lock

   From cppreference.com
   < cpp | thread | unique lock

   C++
   Compiler support
   Freestanding and hosted
   Language
   Standard library
   Standard library headers
   Named requirements
   Feature test macros (C++20)
   Language support library
   Concepts library (C++20)
   Metaprogramming library (C++11)
   Diagnostics library
   General utilities library
   Strings library
   Containers library
   Iterators library
   Ranges library (C++20)
   Algorithms library
   Numerics library
   Localizations library
   Input/output library
   Filesystem library (C++17)
   Regular expressions library (C++11)
   Concurrency support library (C++11)
   Technical specifications
   Symbols index
   External libraries

   Concurrency support library
   Threads
   thread
   (C++11)
   jthread
   (C++20)
   stop_token
   (C++20)
   stop_source
   (C++20)
   stop_callback
   (C++20)
   hardware_destructive_interference_sizehardware_constructive_interferenc
   e_size
   (C++17)(C++17)
   this_thread namespace
   get_id
   (C++11)
   yield
   (C++11)
   sleep_for
   (C++11)
   sleep_until
   (C++11)
   Mutual exclusion
   mutex
   (C++11)
   recursive_mutex
   (C++11)
   shared_mutex
   (C++17)
   timed_mutex
   (C++11)
   recursive_timed_mutex
   (C++11)
   shared_timed_mutex
   (C++14)
   Generic lock management
   lock_guard
   (C++11)
   scoped_lock
   (C++17)
   unique_lock
   (C++11)
   shared_lock
   (C++14)
   defer_lock_ttry_to_lock_tadopt_lock_t
   (C++11)(C++11)(C++11)
   lock
   (C++11)
   try_lock
   (C++11)
   defer_locktry_to_lockadopt_lock
   (C++11)(C++11)(C++11)
   once_flag
   (C++11)
   call_once
   (C++11)
   Condition variables
   condition_variable
   (C++11)
   condition_variable_any
   (C++11)
   notify_all_at_thread_exit
   (C++11)
   cv_status
   (C++11)
   Semaphores
   counting_semaphorebinary_semaphore
   (C++20)(C++20)
   Latches and Barriers
   latch
   (C++20)
   barrier
   (C++20)
   Futures
   promise
   (C++11)
   future
   (C++11)
   shared_future
   (C++11)
   packaged_task
   (C++11)
   async
   (C++11)
   launch
   (C++11)
   future_status
   (C++11)
   future_error
   (C++11)
   future_category
   (C++11)
   future_errc
   (C++11)
   Safe Reclamation
   rcu_obj_base
   (C++26)
   rcu_domain
   (C++26)
   rcu_default_domain
   (C++26)
   rcu_synchronize
   (C++26)
   rcu_barrier
   (C++26)
   rcu_retire
   (C++26)
   Hazard Pointers
   hazard_pointer_obj_base
   (C++26)
   hazard_pointer
   (C++26)
   make_hazard_pointer
   (C++26)
   Atomic types
   atomic
   (C++11)
   atomic_ref
   (C++20)
   atomic_flag
   (C++11)
   Initialization of atomic types
   atomic_init
   (C++11)(deprecated in C++20)
   ATOMIC_VAR_INIT
   (C++11)(deprecated in C++20)
   ATOMIC_FLAG_INIT
   (C++11)
   Memory ordering
   memory_order
   (C++11)
   kill_dependency
   (C++11)
   atomic_thread_fence
   (C++11)
   atomic_signal_fence
   (C++11)
   Free functions for atomic operations
   atomic_storeatomic_store_explicit
   (C++11)(C++11)
   atomic_loadatomic_load_explicit
   (C++11)(C++11)
   atomic_exchangeatomic_exchange_explicit
   (C++11)(C++11)
   atomic_compare_exchange_weakatomic_compare_exchange_weak_explicitatomic
   _compare_exchange_strongatomic_compare_exchange_strong_explicit
   (C++11)(C++11)(C++11)(C++11)
   atomic_fetch_addatomic_fetch_add_explicit
   (C++11)(C++11)
   atomic_fetch_subatomic_fetch_sub_explicit
   (C++11)(C++11)
   atomic_fetch_andatomic_fetch_and_explicit
   (C++11)(C++11)
   atomic_fetch_oratomic_fetch_or_explicit
   (C++11)(C++11)
   atomic_fetch_xoratomic_fetch_xor_explicit
   (C++11)(C++11)
   atomic_fetch_maxatomic_fetch_max_explicit
   (C++26)(C++26)
   atomic_fetch_minatomic_fetch_min_explicit
   (C++26)(C++26)
   atomic_is_lock_free
   (C++11)
   atomic_waitatomic_wait_explicit
   (C++20)(C++20)
   atomic_notify_one
   (C++20)
   atomic_notify_all
   (C++20)
   Free functions for atomic flags
   atomic_flag_test_and_setatomic_flag_test_and_set_explicit
   (C++11)(C++11)
   atomic_flag_clearatomic_flag_clear_explicit
   (C++11)(C++11)
   atomic_flag_testatomic_flag_test_explicit
   (C++20)(C++20)
   atomic_flag_waitatomic_flag_wait_explicit
   (C++20)(C++20)
   atomic_flag_notify_one
   (C++20)
   atomic_flag_notify_all
   (C++20)

   std::unique_lock
   Member functions
   unique_lock::unique_lock
   unique_lock::~unique_lock
   unique_lock::operator=
   Locking
   unique_lock::lock
   unique_lock::try_lock
   unique_lock::try_lock_for
   unique_lock::try_lock_until
   unique_lock::unlock
   Modifiers
   unique_lock::swap
   unique_lock::release
   Observers
   unique_lock::mutex
   unique_lock::owns_lock
   unique_lock::operator bool
   Non-member functions
   swap(std::unique_lock)

   unique_lock() noexcept;
   (1)                                                        (since C++11)
   unique_lock( unique_lock&& other ) noexcept;
   (2)                                                        (since C++11)
   explicit unique_lock( mutex_type& m );
   (3)                                                        (since C++11)
   unique_lock( mutex_type& m, std::defer_lock_t t ) noexcept;
   (4)                                                        (since C++11)
   unique_lock( mutex_type& m, std::try_to_lock_t t );
   (5)                                                        (since C++11)
   unique_lock( mutex_type& m, std::adopt_lock_t t );
   (6)                                                        (since C++11)
   template< class Rep, class Period >

   unique_lock( mutex_type& m,
                const std::chrono::duration<Rep, Period>& timeout_duration
   );
   (7)                                                        (since C++11)
   template< class Clock, class Duration >

   unique_lock( mutex_type& m,
                const std::chrono::time_point<Clock, Duration>&
   timeout_time );
   (8)                                                        (since C++11)

   Constructs a unique_lock, optionally locking the supplied mutex.
   1) Constructs a unique_lock with no associated mutex.
   2) Move constructor. Initializes the unique_lock with the contents of
   other. Leaves other with no associated mutex.
   3-8) Constructs a unique_lock with m as the associated mutex.
   Additionally:
   3) Locks the associated mutex by calling m.lock().
   4) Does not lock the associated mutex.
   5) Tries to lock the associated mutex without blocking by calling
   m.try_lock(). The behavior is undefined if Mutex does not satisfy
   Lockable.
   6) Assumes the calling thread already holds a non-shared lock (i.e., a
   lock acquired by lock, try_lock, try_lock_for, or try_lock_until) on m.
   The behavior is undefined if not so.
   7) Tries to lock the associated mutex by calling
   m.try_lock_for(timeout_duration). Blocks until specified
   timeout_duration has elapsed or the lock is acquired, whichever comes
   first. May block for longer than timeout_duration. The behavior is
   undefined if Mutex does not satisfy TimedLockable.
   8) Tries to lock the associated mutex by calling
   m.try_lock_until(timeout_time). Blocks until specified timeout_time has
   been reached or the lock is acquired, whichever comes first. May block
   for longer than until timeout_time has been reached. The behavior is
   undefined if Mutex does not satisfy TimedLockable.

Parameters

   other - another unique_lock to initialize the state with
   m - mutex to associate with the lock and optionally acquire ownership
   of
   t - tag parameter used to select constructors with different locking
   strategies
   timeout_duration - maximum duration to block for
   timeout_time - maximum time point to block until

Example

   Run this code
#include <iostream>
#include <mutex>
#include <thread>
#include <utility>
#include <vector>

std::mutex m_a, m_b, m_c;
int a, b, c = 1;

void update()
{
    {   // Note: std::lock_guard or atomic<int> can be used instead
        std::unique_lock<std::mutex> lk(m_a);
        ++a;
    }

    {   // Note: see std::lock and std::scoped_lock for details and alternatives
        std::unique_lock<std::mutex> lk_b(m_b, std::defer_lock);
        std::unique_lock<std::mutex> lk_c(m_c, std::defer_lock);
        std::lock(lk_b, lk_c);
        b = std::exchange(c, b + c);
    }
}

int main()
{
    std::vector<std::thread> threads;
    for (unsigned i = 0; i < 12; ++i)
        threads.emplace_back(update);

    for (auto& i : threads)
        i.join();

    std::cout << a << "'th and " << a + 1 << "'th Fibonacci numbers: "
              << b << " and " << c << '\n';
}

   Output:
12'th and 13'th Fibonacci numbers: 144 and 233

   Retrieved from
   "https://en.cppreference.com/mwiki/index.php?title=cpp/thread/unique_lo
   ck/unique_lock&oldid=161298"

Navigation

     * Online version
     * Offline version retrieved 2024-06-10 08:17.

     * This page was last modified on 24 October 2023, at 11:40.
     * This page has been accessed 290,090 times.
