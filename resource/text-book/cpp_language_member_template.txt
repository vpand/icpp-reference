Member templates

   From cppreference.com
   < cpp | language

   C++
   Compiler support
   Freestanding and hosted
   Language
   Standard library
   Standard library headers
   Named requirements
   Feature test macros (C++20)
   Language support library
   Concepts library (C++20)
   Metaprogramming library (C++11)
   Diagnostics library
   General utilities library
   Strings library
   Containers library
   Iterators library
   Ranges library (C++20)
   Algorithms library
   Numerics library
   Localizations library
   Input/output library
   Filesystem library (C++17)
   Regular expressions library (C++11)
   Concurrency support library (C++11)
   Technical specifications
   Symbols index
   External libraries

   C++ language
   General topics
   Preprocessor
   Comments
   Keywords
   Escape sequences
   Flow control
   Conditional execution statements
   if
   switch
   Iteration statements (loops)
   for
   range-for (C++11)
   while
   do-while
   Jump statements
   continue - break
   goto - return
   Functions
   Function declaration
   Lambda function expression
   inline specifier
   Dynamic exception specifications (until C++17*)
   noexcept specifier (C++11)
   Exceptions
   throw-expression
   try block
   handler
   Namespaces
   Namespace declaration
   Namespace aliases
   Types
   Fundamental types
   Enumeration types
   Function types
   Class/struct types
   Union types
   Specifiers
   const/volatile
   decltype (C++11)
   auto (C++11)
   constexpr (C++11)
   consteval (C++20)
   constinit (C++20)
   Storage duration specifiers
   Initialization
   Default-initialization
   Value-initialization
   Zero-initialization
   Copy-initialization
   Direct-initialization
   Aggregate initialization
   List-initialization (C++11)
   Constant initialization
   Reference initialization
   Expressions
   Value categories
   Order of evaluation
   Operators
   Operator precedence
   Alternative representations
   Literals
   Boolean - Integer - Floating-point
   Character - String - nullptr (C++11)
   User-defined (C++11)
   Utilities
   Attributes (C++11)
   Types
   typedef declaration
   Type alias declaration (C++11)
   Casts
   Implicit conversions
   static_cast
   const_cast
   Explicit conversions
   dynamic_cast
   reinterpret_cast
   Memory allocation
   new expression
   delete expression
   Classes
   Class declaration
   Constructors
   this pointer
   Access specifiers
   friend specifier
   Class-specific function properties
   Virtual function
   override specifier (C++11)
   final specifier (C++11)
   explicit (C++11)
   static
   Special member functions
   Default constructor
   Copy constructor
   Move constructor (C++11)
   Copy assignment
   Move assignment (C++11)
   Destructor
   Templates
   Class template
   Function template
   Template specialization
   Parameter packs (C++11)
   Miscellaneous
   Inline assembly
   History of C++

   Declarations
   Overview
   Declaration syntax
   decl-specifier-seq
   Declarator
   Conflicting declarations
   Specifiers
   typedef
   inline
   virtual function specifier
   explicit function specifier
   friend
   constexpr
   (C++11)
   consteval
   (C++20)
   constinit
   (C++20)
   Storage class specifiers
   Translation-unit-local (C++20)
   class/struct
   union
   enum
   decltype
   (C++11)
   auto
   (C++11)
   alignas
   (C++11)
   constvolatile
   Pack indexing specifier (C++26)
   Elaborated type specifier
   Attributes (C++11)
   Declarators
   Reference
   Pointer
   Array
   Block declarations
   Simple-declaration
   ->Structured binding declaration (C++17)
   Alias declaration (C++11)
   Namespace alias definition
   using declaration
   using directive
   static_assert declaration (C++11)
   asm declaration
   Opaque enum declaration (C++11)
   Other declarations
   Namespace definition
   Function declaration
   Class template declaration
   Function template declaration
   Explicit template instantiation (C++11)
   Explicit template specialization
   Linkage specification
   Attribute declaration (C++11)
   Empty declaration

   Expressions
   General
   Value categories
   Order of evaluation
   Constant expressions
   Primary expressions
   Lambda expressions (C++11)
   Pack indexing expression (C++26)
   Potentially-evaluated expressions
   Literals
   Integer literals
   Floating-point literals
   Boolean literals
   Character literals
   Escape sequences
   String literals
   Null pointer literal (C++11)
   User-defined literal (C++11)
   Operators
   Assignment operators
   Increment and decrement
   Arithmetic operators
   Logical operators
   Comparison operators
   Member access operators
   Other operators
   new-expression
   delete-expression
   throw-expression
   alignof
   sizeof
   sizeof... (C++11)
   typeid
   noexcept (C++11)
   Fold expressions (C++17)
   Alternative representations of operators
   Precedence and associativity
   Operator overloading
   Default comparisons (C++20)
   Conversions
   Implicit conversions
   Explicit conversions
   Usual arithmetic conversions
   User-defined conversion
   const_cast
   static_cast
   dynamic_cast
   reinterpret_cast

   Templates
   Parameters and arguments
   Class templates
   Function templates
   Class member templates
   Variable templates (C++14)
   Template argument deduction
   Class template argument deduction (C++17)
   Explicit (full) specialization
   Partial specialization
   Dependent names
   Parameter packs (C++11)
      sizeof... (C++11)
      Fold expressions (C++17)
      Pack indexing (C++26)
   SFINAE
   Constraints and concepts (C++20)
   Requires expression (C++20)

   Template declarations (class, function, and variables(since C++14)) can
   appear inside a member specification of any class, struct, or union
   that are not local classes.
   Run this code
#include <algorithm>
#include <iostream>
#include <string>
#include <vector>

struct Printer
{
    // generic functor
    std::ostream& os;
    Printer(std::ostream& os) : os(os) {}
    template<typename T>
    void operator()(const T& obj) { os << obj << ' '; } // member template
};

int main()
{
    std::vector<int> v{1,2,3};
    std::for_each(v.begin(), v.end(), Printer(std::cout));
    std::string s{"abc"};
    std::ranges::for_each(s, Printer(std::cout));
}

   Output:
1 2 3 a b c

   Partial specializations of member template may appear both at class
   scope and at enclosing namespace scope. Explicit specializations may
   appear in any scope in which the primary template may appear.
struct A
{
    template<class T> struct B;        // primary member template
    template<class T> struct B<T*> {}; // OK: partial specialization
//  template<> struct B<int*> {};      // OK via CWG 727: full specialization
};
template<> struct A::B<int*> {};       // OK
template<class T> struct A::B<T&> {};  // OK

   If the enclosing class declaration is, in turn, a class template, when
   a member template is defined outside of the class body, it takes two
   sets of template parameters: one for the enclosing class, and another
   one for itself:
template<typename T1>
struct string
{
    // member template function
    template<typename T2>
    int compare(const T2&);
    // constructors can be templates too
    template<typename T2>
    string(const std::basic_string<T2>& s) { /*...*/ }
};
// out of class definition of string<T1>::compare<T2>
template<typename T1> // for the enclosing class template
template<typename T2> // for the member template
int string<T1>::compare(const T2& s) { /* ... */ }

Member function templates

   Destructors and copy constructors cannot be templates. If a template
   constructor is declared which could be instantiated with the type
   signature of a copy constructor, the implicitly-declared copy
   constructor is used instead.

   A member function template cannot be virtual, and a member function
   template in a derived class cannot override a virtual member function
   from the base class.
class Base
{
    virtual void f(int);
};

struct Derived : Base
{
    // this member template does not override Base::f
    template<class T> void f(T);

    // non-template member override can call the template:
    void f(int i) override
    {
         f<>(i);
    }
};

   A non-template member function and a template member function with the
   same name may be declared. In case of conflict (when some template
   specialization matches the non-template function signature exactly),
   the use of that name and type refers to the non-template member unless
   an explicit template argument list is supplied.
template<typename T>
struct A
{
    void f(int); // non-template member

    template<typename T2>
    void f(T2); // member template
};

// template member definition
template<typename T>
template<typename T2>
void A<T>::f(T2)
{
    // some code
}

int main()
{
    A<char> ac;
    ac.f('c'); // calls template function A<char>::f<char>(char)
    ac.f(1);   // calls non-template function A<char>::f(int)
    ac.f<>(1); // calls template function A<char>::f<int>(int)
}

   An out-of-class definition of a member function template must be
   equivalent to the declaration inside the class (see function template
   overloading for the definition of equivalency), otherwise it is
   considered to be an overload.
struct X
{
    template<class T> T good(T n);
    template<class T> T bad(T n);
};

template<class T> struct identity { using type = T; };

// OK: equivalent declaration
template<class V>
V X::good(V n) { return n; }

// Error: not equivalent to any of the declarations inside X
template<class T>
T X::bad(typename identity<T>::type n) { return n; }

Conversion function templates

   A user-defined conversion function can be a template.
struct A
{
    template<typename T>
    operator T*(); // conversion to pointer to any type
};

// out-of-class definition
template<typename T>
A::operator T*() { return nullptr; }

// explicit specialization for char*
template<>
A::operator char*() { return nullptr; }

// explicit instantiation
template A::operator void*();

int main()
{
    A a;
    int* ip = a.operator int*(); // explicit call to A::operator int*()
}

   During overload resolution, specializations of conversion function
   templates are not found by name lookup. Instead, all visible conversion
   function templates are considered, and every specialization produced by
   template argument deduction (which has special rules for conversion
   function templates) is used as if found by name lookup.

   Using-declarations in derived classes cannot refer to specializations
   of template conversion functions from base classes.

   A user-defined conversion function template cannot have a deduced
   return type:
struct S
{
    operator auto() const { return 10; } // OK
    template<class T> operator auto() const { return 42; } // error
};

   (since C++14)

Member variable templates

   A variable template declaration may appear at class scope, in which
   case it declares a static data member template. See variable templates
   for details.
   (since C++14)

Defect reports

   The following behavior-changing defect reports were applied
   retroactively to previously published C++ standards.
   DR Applied to Behavior as published Correct behavior
   CWG 1878 C++14 operator auto was technically allowed operator auto
   forbidden
   Retrieved from
   "https://en.cppreference.com/mwiki/index.php?title=cpp/language/member_
   template&oldid=167756"

Navigation

     * Online version
     * Offline version retrieved 2024-06-10 08:17.

     * This page was last modified on 29 December 2023, at 21:56.
     * This page has been accessed 667,108 times.
