std::thread::thread

   From cppreference.com
   < cpp | thread | thread

   C++
   Compiler support
   Freestanding and hosted
   Language
   Standard library
   Standard library headers
   Named requirements
   Feature test macros (C++20)
   Language support library
   Concepts library (C++20)
   Metaprogramming library (C++11)
   Diagnostics library
   General utilities library
   Strings library
   Containers library
   Iterators library
   Ranges library (C++20)
   Algorithms library
   Numerics library
   Localizations library
   Input/output library
   Filesystem library (C++17)
   Regular expressions library (C++11)
   Concurrency support library (C++11)
   Technical specifications
   Symbols index
   External libraries

   Concurrency support library
   Threads
   thread
   (C++11)
   jthread
   (C++20)
   stop_token
   (C++20)
   stop_source
   (C++20)
   stop_callback
   (C++20)
   hardware_destructive_interference_sizehardware_constructive_interferenc
   e_size
   (C++17)(C++17)
   this_thread namespace
   get_id
   (C++11)
   yield
   (C++11)
   sleep_for
   (C++11)
   sleep_until
   (C++11)
   Mutual exclusion
   mutex
   (C++11)
   recursive_mutex
   (C++11)
   shared_mutex
   (C++17)
   timed_mutex
   (C++11)
   recursive_timed_mutex
   (C++11)
   shared_timed_mutex
   (C++14)
   Generic lock management
   lock_guard
   (C++11)
   scoped_lock
   (C++17)
   unique_lock
   (C++11)
   shared_lock
   (C++14)
   defer_lock_ttry_to_lock_tadopt_lock_t
   (C++11)(C++11)(C++11)
   lock
   (C++11)
   try_lock
   (C++11)
   defer_locktry_to_lockadopt_lock
   (C++11)(C++11)(C++11)
   once_flag
   (C++11)
   call_once
   (C++11)
   Condition variables
   condition_variable
   (C++11)
   condition_variable_any
   (C++11)
   notify_all_at_thread_exit
   (C++11)
   cv_status
   (C++11)
   Semaphores
   counting_semaphorebinary_semaphore
   (C++20)(C++20)
   Latches and Barriers
   latch
   (C++20)
   barrier
   (C++20)
   Futures
   promise
   (C++11)
   future
   (C++11)
   shared_future
   (C++11)
   packaged_task
   (C++11)
   async
   (C++11)
   launch
   (C++11)
   future_status
   (C++11)
   future_error
   (C++11)
   future_category
   (C++11)
   future_errc
   (C++11)
   Safe Reclamation
   rcu_obj_base
   (C++26)
   rcu_domain
   (C++26)
   rcu_default_domain
   (C++26)
   rcu_synchronize
   (C++26)
   rcu_barrier
   (C++26)
   rcu_retire
   (C++26)
   Hazard Pointers
   hazard_pointer_obj_base
   (C++26)
   hazard_pointer
   (C++26)
   make_hazard_pointer
   (C++26)
   Atomic types
   atomic
   (C++11)
   atomic_ref
   (C++20)
   atomic_flag
   (C++11)
   Initialization of atomic types
   atomic_init
   (C++11)(deprecated in C++20)
   ATOMIC_VAR_INIT
   (C++11)(deprecated in C++20)
   ATOMIC_FLAG_INIT
   (C++11)
   Memory ordering
   memory_order
   (C++11)
   kill_dependency
   (C++11)
   atomic_thread_fence
   (C++11)
   atomic_signal_fence
   (C++11)
   Free functions for atomic operations
   atomic_storeatomic_store_explicit
   (C++11)(C++11)
   atomic_loadatomic_load_explicit
   (C++11)(C++11)
   atomic_exchangeatomic_exchange_explicit
   (C++11)(C++11)
   atomic_compare_exchange_weakatomic_compare_exchange_weak_explicitatomic
   _compare_exchange_strongatomic_compare_exchange_strong_explicit
   (C++11)(C++11)(C++11)(C++11)
   atomic_fetch_addatomic_fetch_add_explicit
   (C++11)(C++11)
   atomic_fetch_subatomic_fetch_sub_explicit
   (C++11)(C++11)
   atomic_fetch_andatomic_fetch_and_explicit
   (C++11)(C++11)
   atomic_fetch_oratomic_fetch_or_explicit
   (C++11)(C++11)
   atomic_fetch_xoratomic_fetch_xor_explicit
   (C++11)(C++11)
   atomic_fetch_maxatomic_fetch_max_explicit
   (C++26)(C++26)
   atomic_fetch_minatomic_fetch_min_explicit
   (C++26)(C++26)
   atomic_is_lock_free
   (C++11)
   atomic_waitatomic_wait_explicit
   (C++20)(C++20)
   atomic_notify_one
   (C++20)
   atomic_notify_all
   (C++20)
   Free functions for atomic flags
   atomic_flag_test_and_setatomic_flag_test_and_set_explicit
   (C++11)(C++11)
   atomic_flag_clearatomic_flag_clear_explicit
   (C++11)(C++11)
   atomic_flag_testatomic_flag_test_explicit
   (C++20)(C++20)
   atomic_flag_waitatomic_flag_wait_explicit
   (C++20)(C++20)
   atomic_flag_notify_one
   (C++20)
   atomic_flag_notify_all
   (C++20)

   std::thread
   Member classes
   thread::id
   Member functions
   thread::thread
   thread::~thread
   thread::operator=
   Observers
   thread::joinable
   thread::get_id
   thread::native_handle
   thread::hardware_concurrency
   Operations
   thread::join
   thread::detach
   thread::swap
   Non-member functions
   swap(std::thread)

   thread() noexcept;
   (1)                               (since C++11)
   thread( thread&& other ) noexcept;
   (2)                               (since C++11)
   template< class F, class... Args >
   explicit thread( F&& f, Args&&... args );
   (3)                               (since C++11)
   thread( const thread& ) = delete;
   (4)                               (since C++11)

   Constructs a new std::thread object.
   1) Creates a new std::thread object which does not represent a thread.
   2) Move constructor. Constructs the std::thread object to represent the
   thread of execution that was represented by other. After this call
   other no longer represents a thread of execution.
   3) Creates a new std::thread object and associates it with a thread of
   execution. The new thread of execution starts executing:

   INVOKE(decay-copy(std::forward<F>(f)),
          decay-copy(std::forward<Args>(args))...)
   (until C++23)

   std::invoke(auto(std::forward<F>(f)),
               auto(std::forward<Args>(args))...)
   (since C++23)
   The calls of decay-copy are evaluated(until C++23)The values produced
   by auto are materialized(since C++23) in the current thread, so that
   any exceptions thrown during evaluation and copying/moving of the
   arguments are thrown in the current thread, without starting the new
   thread.
   This overload participates in overload resolution only if
   std::decay<F>::type(until C++20)std::remove_cvref_t<F>(since C++20) is
   not the same type as std::thread.

   If any of the following conditions is satisfied, the program is
   ill-formed:
     * F is not MoveConstructible.
     * Any type in Args is not MoveConstructible.
     * INVOKE(decay-copy(std::forward<F>(f)),
              decay-copy(std::forward<Args>(args))...) is not a valid
       expression.

   (until C++20)

   If any of the following is false, the program is ill-formed:
     * std::is_constructible_v<std::decay_t<F>, F>
     * (std::is_constructible_v<std::decay_t<Args>, Args> && ...)
     * std::is_invocable_v<std::decay_t<F>, std::decay_t<Args>...>

   (since C++20)
   The completion of the invocation of the constructor synchronizes with
   the beginning of the invocation of the copy of f on the new thread of
   execution.
   4) The copy constructor is deleted; threads are not copyable. No two
   std::thread objects may represent the same thread of execution.

Parameters

   other - another thread object to construct this thread object with
   f     - Callable object to execute in the new thread
   args  - arguments to pass to the new function

Postconditions

   1) get_id() equal to std::thread::id() (i.e. joinable() is false).
   2) other.get_id() equal to std::thread::id() and get_id() returns the
   value of other.get_id() prior to the start of construction.
   3) get_id() not equal to std::thread::id() (i.e. joinable() is true).

Exceptions

   3) std::system_error if the thread could not be started. The exception
   may represent the error condition
   std::errc::resource_unavailable_try_again or another
   implementation-specific error condition.

Notes

   The arguments to the thread function are moved or copied by value. If a
   reference argument needs to be passed to the thread function, it has to
   be wrapped (e.g., with std::ref or std::cref).

   Any return value from the function is ignored. If the function throws
   an exception, std::terminate is called. In order to pass return values
   or exceptions back to the calling thread, std::promise or std::async
   may be used.

Example

   Run this code
#include <chrono>
#include <iostream>
#include <thread>
#include <utility>

void f1(int n)
{
    for (int i = 0; i < 5; ++i)
    {
        std::cout << "Thread 1 executing\n";
        ++n;
        std::this_thread::sleep_for(std::chrono::milliseconds(10));
    }
}

void f2(int& n)
{
    for (int i = 0; i < 5; ++i)
    {
        std::cout << "Thread 2 executing\n";
        ++n;
        std::this_thread::sleep_for(std::chrono::milliseconds(10));
    }
}

class foo
{
public:
    void bar()
    {
        for (int i = 0; i < 5; ++i)
        {
            std::cout << "Thread 3 executing\n";
            ++n;
            std::this_thread::sleep_for(std::chrono::milliseconds(10));
        }
    }
    int n = 0;
};

class baz
{
public:
    void operator()()
    {
        for (int i = 0; i < 5; ++i)
        {
            std::cout << "Thread 4 executing\n";
            ++n;
            std::this_thread::sleep_for(std::chrono::milliseconds(10));
        }
    }
    int n = 0;
};

int main()
{
    int n = 0;
    foo f;
    baz b;
    std::thread t1; // t1 is not a thread
    std::thread t2(f1, n + 1); // pass by value
    std::thread t3(f2, std::ref(n)); // pass by reference
    std::thread t4(std::move(t3)); // t4 is now running f2(). t3 is no longer a
thread
    std::thread t5(&foo::bar, &f); // t5 runs foo::bar() on object f
    std::thread t6(b); // t6 runs baz::operator() on a copy of object b
    t2.join();
    t4.join();
    t5.join();
    t6.join();
    std::cout << "Final value of n is " << n << '\n';
    std::cout << "Final value of f.n (foo::n) is " << f.n << '\n';
    std::cout << "Final value of b.n (baz::n) is " << b.n << '\n';
}

   Possible output:
Thread 1 executing
Thread 2 executing
Thread 3 executing
Thread 4 executing
Thread 3 executing
Thread 1 executing
Thread 2 executing
Thread 4 executing
Thread 2 executing
Thread 3 executing
Thread 1 executing
Thread 4 executing
Thread 3 executing
Thread 2 executing
Thread 1 executing
Thread 4 executing
Thread 3 executing
Thread 1 executing
Thread 2 executing
Thread 4 executing
Final value of n is 5
Final value of f.n (foo::n) is 5
Final value of b.n (baz::n) is 0

Defect reports

   The following behavior-changing defect reports were applied
   retroactively to previously published C++ standards.
   DR Applied to Behavior as published Correct behavior
   LWG 2097 C++11 for overload (3), F could be std::thread F is
   constrained
   LWG 3476 C++20 overload (3) directly required (the decayed types of)
   F and the argument types to be move constructible removed these
   requirements^[1]
    1. ^| The move-constructibility is already indirectly required by
       std::is_constructible_v.

References

     * C++23 standard (ISO/IEC 14882:2023):

          + 33.4.3.3 thread constructors [thread.thread.constr]

     * C++20 standard (ISO/IEC 14882:2020):

          + 32.4.2.2 thread constructors [thread.thread.constr]

     * C++17 standard (ISO/IEC 14882:2017):

          + 33.3.2.2 thread constructors [thread.thread.constr]

     * C++14 standard (ISO/IEC 14882:2014):

          + 30.3.1.2 thread constructors [thread.thread.constr]

     * C++11 standard (ISO/IEC 14882:2011):

          + 30.3.1.2 thread constructors [thread.thread.constr]

See also

   (constructor)
   constructs new jthread object
   (public member function of std::jthread)
   Retrieved from
   "https://en.cppreference.com/mwiki/index.php?title=cpp/thread/thread/th
   read&oldid=169925"

Navigation

     * Online version
     * Offline version retrieved 2024-06-10 08:17.

     * This page was last modified on 23 February 2024, at 01:53.
     * This page has been accessed 1,107,645 times.
