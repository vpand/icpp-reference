std::launder

   From cppreference.com
   < cpp | utility

   C++
   Compiler support
   Freestanding and hosted
   Language
   Standard library
   Standard library headers
   Named requirements
   Feature test macros (C++20)
   Language support library
   Concepts library (C++20)
   Metaprogramming library (C++11)
   Diagnostics library
   General utilities library
   Strings library
   Containers library
   Iterators library
   Ranges library (C++20)
   Algorithms library
   Numerics library
   Localizations library
   Input/output library
   Filesystem library (C++17)
   Regular expressions library (C++11)
   Concurrency support library (C++11)
   Technical specifications
   Symbols index
   External libraries

   Utilities library
   Language support
   Type support (basic types, RTTI)
   Library feature-test macros (C++20)
   Dynamic memory management
   Program utilities
   Coroutine support (C++20)
   Variadic functions
   is_constant_evaluated
   (C++20)
   is_within_lifetime
   (C++26)
   initializer_list
   (C++11)
   source_location
   (C++20)
   Debugging support
   is_debugger_present
   (C++26)
   breakpoint_if_debugging
   (C++26)
   breakpoint
   (C++26)
   Three-way comparison
   three_way_comparablethree_way_comparable_with
   (C++20)(C++20)
   strong_ordering
   (C++20)
   weak_ordering
   (C++20)
   partial_ordering
   (C++20)
   common_comparison_category
   (C++20)
   compare_three_way_result
   (C++20)
   compare_three_way
   (C++20)
   strong_order
   (C++20)
   weak_order
   (C++20)
   partial_order
   (C++20)
   compare_strong_order_fallback
   (C++20)
   compare_weak_order_fallback
   (C++20)
   compare_partial_order_fallback
   (C++20)
   is_eqis_ltis_lteq
   (C++20)(C++20)(C++20)
   is_neqis_gtis_gteq
   (C++20)(C++20)(C++20)
   General utilities
   Date and time
   Function objects
   Formatting library (C++20)
   bitset
   hash
   (C++11)
   Relational operators (deprecated in C++20)
   rel_ops::operator!=rel_ops::operator>

   rel_ops::operator<=rel_ops::operator>=
   Integer comparison functions
   cmp_equalcmp_lesscmp_less_than
   (C++20)(C++20)(C++20)
   cmp_not_equalcmp_greatercmp_greater_than
   (C++20)(C++20)(C++20)
   in_range
   (C++20)
   Swap and type operations
   swap
   ranges::swap
   (C++20)
   exchange
   (C++14)
   declval
   (C++11)
   to_underlying
   (C++23)
   forward
   (C++11)
   forward_like
   (C++23)
   move
   (C++11)
   move_if_noexcept
   (C++11)
   as_const
   (C++17)
   Common vocabulary types
   pair
   tuple
   (C++11)
   optional
   (C++17)
   any
   (C++17)
   variant
   (C++17)
   tuple_size
   (C++11)
   tuple_element
   (C++11)
   apply
   (C++17)
   make_from_tuple
   (C++17)
   expected
   (C++23)
   Elementary string conversions
   to_chars
   (C++17)
   from_chars
   (C++17)
   chars_format
   (C++17)
   to_chars_result
   (C++17)
   from_chars_result
   (C++17)

   Dynamic memory management
   Uninitialized memory algorithms
   uninitialized_copy
   uninitialized_fill
   uninitialized_move
   (C++17)
   uninitialized_default_construct
   (C++17)
   uninitialized_value_construct
   (C++17)
   destroy
   (C++17)
   destroy_at
   (C++17)
   voidify
   (C++20)
   uninitialized_copy_n
   (C++11)
   uninitialized_fill_n
   uninitialized_move_n
   (C++17)
   uninitialized_default_construct_n
   (C++17)
   uninitialized_value_construct_n
   (C++17)
   destroy_n
   (C++17)
   construct_at
   (C++20)
   Constrained uninitialized memory algorithms
   ranges::uninitialized_copy
   (C++20)
   ranges::uninitialized_fill
   (C++20)
   ranges::uninitialized_move
   (C++20)
   ranges::construct_at
   (C++20)
   ranges::destroy
   (C++20)
   ranges::destroy_n
   (C++20)
   ranges::destroy_at
   (C++20)
   ranges::uninitialized_copy_n
   (C++20)
   ranges::uninitialized_fill_n
   (C++20)
   ranges::uninitialized_move_n
   (C++20)
   ranges::uninitialized_default_construct
   (C++20)
   ranges::uninitialized_value_construct
   (C++20)
   ranges::uninitialized_default_construct_n
   (C++20)
   ranges::uninitialized_value_construct_n
   (C++20)
   Allocators
   allocator
   allocator_traits
   (C++11)
   allocation_result
   (C++23)
   allocator_arg
   (C++11)
   uses_allocator
   (C++11)
   uses_allocator_construction_args
   (C++20)
   make_obj_using_allocator
   (C++20)
   uninitialized_construct_using_allocator
   (C++20)
   scoped_allocator_adaptor
   (C++11)
   pmr::polymorphic_allocator
   (C++17)
   Memory resources
   pmr::memory_resource
   (C++17)
   pmr::get_default_resource
   (C++17)
   pmr::set_default_resource
   (C++17)
   pmr::new_delete_resource
   (C++17)
   pmr::null_memory_resource
   (C++17)
   pmr::synchronized_pool_resource
   (C++17)
   pmr::unsynchronized_pool_resource
   (C++17)
   pmr::monotonic_buffer_resource
   (C++17)
   pmr::pool_options
   (C++17)
   Garbage collection support
   declare_reachable
   (C++11)(until C++23)
   undeclare_reachable
   (C++11)(until C++23)
   declare_no_pointers
   (C++11)(until C++23)
   undeclare_no_pointers
   (C++11)(until C++23)
   pointer_safety
   (C++11)(until C++23)
   get_pointer_safety
   (C++11)(until C++23)
   Uninitialized storage
   raw_storage_iterator
   (until C++20*)
   get_temporary_buffer
   (until C++20*)
   return_temporary_buffer
   (until C++20*)
   Explicit lifetime management
   start_lifetime_asstart_lifetime_as_array
   (C++23)(C++23)
   Smart pointers
   unique_ptr
   (C++11)
   shared_ptr
   (C++11)
   weak_ptr
   (C++11)
   auto_ptr
   (until C++17*)
   owner_less
   (C++11)
   owner_less<void>
   (C++17)
   owner_hash
   (C++26)
   owner_equal
   (C++26)
   enable_shared_from_this
   (C++11)
   bad_weak_ptr
   (C++11)
   default_delete
   (C++11)
   out_ptr_t
   (C++23)
   inout_ptr_t
   (C++23)
   Low level memory
   management
   operator new
   operator new[]
   operator delete
   operator delete[]
   get_new_handler
   set_new_handler
   launder
   (C++17)
   bad_alloc
   bad_array_new_length
   nothrow_t
   align_val_t
   destroying_delete_t
   new_handler
   nothrow
   Miscellaneous
   pointer_traits
   (C++11)
   to_address
   (C++20)
   addressof
   (C++11)
   align
   (C++11)
   assume_aligned
   (C++20)
   C Library
   malloc
   calloc
   realloc

   aligned_alloc
   (C++17)
   free

   Low level memory management
   Functions
   operator newoperator new[]
   operator deleteoperator delete[]
   get_new_handler
   (C++11)
   set_new_handler
   Classes
   bad_alloc
   bad_array_new_length
   (C++11)
   align_val_t
   (C++17)
   Types
   new_handler
   Objects
   nothrow
   destroying_delete
   (C++20)
   Object access
   launder
   (C++17)

   Defined in header <new>
   template< class T >
   constexpr T* launder( T* p ) noexcept;
   (since C++17)
   (until C++20)
   template< class T >
   [[nodiscard]] constexpr T* launder( T* p ) noexcept;
                          (since C++20)

   Provenance fence with respect to p. Returns a pointer to the same
   memory that p points to, but where the referent object is assumed to
   have a distinct lifetime and dynamic type.

   Formally, given
     * the pointer p represents the address A of a byte in memory
     * an object x is located at the address A
     * x is within its lifetime
     * the type of x is the same as T, ignoring cv-qualifiers at every
       level
     * every byte that would be reachable through the result is reachable
       through p (bytes are reachable through a pointer that points to an
       object y if those bytes are within the storage of an object z that
       is pointer-interconvertible with y, or within the immediately
       enclosing array of which z is an element).

   Then std::launder(p) returns a value of type T* that points to the
   object x. Otherwise, the behavior is undefined.

   The program is ill-formed if T is a function type or (possibly
   cv-qualified) void.

   std::launder may be used in a core constant expression if and only if
   the (converted) value of its argument may be used in place of the
   function invocation. In other words, std::launder does not relax
   restrictions in constant evaluation.

Notes

   std::launder has no effect on its argument. Its return value must be
   used to access the object. Thus, it's always an error to discard the
   return value.

   Typical uses of std::launder include:
     * Obtaining a pointer to an object created in the storage of an
       existing object of the same type, where pointers to the old object
       cannot be reused (for instance, because either object is a base
       class subobject);
     * Obtaining a pointer to an object created by placement new from a
       pointer to an object providing storage for that object.

   The reachability restriction ensures that std::launder cannot be used
   to access bytes not accessible through the original pointer, thereby
   interfering with the compiler's escape analysis.
int x[10];
auto p = std::launder(reinterpret_cast<int(*)[10]>(&x[0])); // OK

int x2[2][10];
auto p2 = std::launder(reinterpret_cast<int(*)[10]>(&x2[0][0]));
// Undefined behavior: x2[1] would be reachable through the resulting pointer to
 x2[0]
// but is not reachable from the source

struct X { int a[10]; } x3, x4[2]; // standard layout; assume no padding
auto p3 = std::launder(reinterpret_cast<int(*)[10]>(&x3.a[0])); // OK
auto p4 = std::launder(reinterpret_cast<int(*)[10]>(&x4[0].a[0]));
// Undefined behavior: x4[1] would be reachable through the resulting pointer to
 x4[0].a
// (which is pointer-interconvertible with x4[0]) but is not reachable from the
source

struct Y { int a[10]; double y; } x5;
auto p5 = std::launder(reinterpret_cast<int(*)[10]>(&x5.a[0]));
// Undefined behavior: x5.y would be reachable through the resulting pointer to
x5.a
// but is not reachable from the source

Example

   Run this code
#include <cassert>
#include <cstddef>
#include <new>

struct Base
{
    virtual int transmogrify();
};

struct Derived : Base
{
    int transmogrify() override
    {
        new(this) Base;
        return 2;
    }
};

int Base::transmogrify()
{
    new(this) Derived;
    return 1;
}

static_assert(sizeof(Derived) == sizeof(Base));

int main()
{
    // Case 1: the new object failed to be transparently replaceable because
    // it is a base subobject but the old object is a complete object.
    Base base;
    int n = base.transmogrify();
    // int m = base.transmogrify(); // undefined behavior
    int m = std::launder(&base)->transmogrify(); // OK
    assert(m + n == 3);

    // Case 2: access to a new object whose storage is provided
    // by a byte array through a pointer to the array.
    struct Y { int z; };
    alignas(Y) std::byte s[sizeof(Y)];
    Y* q = new(&s) Y{2};
    const int f = reinterpret_cast<Y*>(&s)->z; // Class member access is undefin
ed
                                               // behavior: reinterpret_cast<Y*>
(&s)
                                               // has value "pointer to s" and d
oes
                                               // not point to a Y object
    const int g = q->z; // OK
    const int h = std::launder(reinterpret_cast<Y*>(&s))->z; // OK

    [](...){}(f, g, h); // evokes [[maybe_unused]] effect
}

Defect reports

   The following behavior-changing defect reports were applied
   retroactively to previously published C++ standards.
   DR Applied to Behavior as published Correct behavior
   LWG 2859 C++17 definition of reachable did not consider pointer
   arithmetic from pointer-interconvertible object included
   LWG 3495 C++17 std::launder might make pointer to an inactive
   member dereferenceable in constant expression forbidden
   Retrieved from
   "https://en.cppreference.com/mwiki/index.php?title=cpp/utility/launder&
   oldid=151712"

Navigation

     * Online version
     * Offline version retrieved 2024-06-10 08:17.

     * This page was last modified on 15 May 2023, at 01:29.
     * This page has been accessed 238,899 times.
