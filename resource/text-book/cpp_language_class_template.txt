Class template

   From cppreference.com
   < cpp | language

   C++
   Compiler support
   Freestanding and hosted
   Language
   Standard library
   Standard library headers
   Named requirements
   Feature test macros (C++20)
   Language support library
   Concepts library (C++20)
   Metaprogramming library (C++11)
   Diagnostics library
   General utilities library
   Strings library
   Containers library
   Iterators library
   Ranges library (C++20)
   Algorithms library
   Numerics library
   Localizations library
   Input/output library
   Filesystem library (C++17)
   Regular expressions library (C++11)
   Concurrency support library (C++11)
   Technical specifications
   Symbols index
   External libraries

   C++ language
   General topics
   Preprocessor
   Comments
   Keywords
   Escape sequences
   Flow control
   Conditional execution statements
   if
   switch
   Iteration statements (loops)
   for
   range-for (C++11)
   while
   do-while
   Jump statements
   continue - break
   goto - return
   Functions
   Function declaration
   Lambda function expression
   inline specifier
   Dynamic exception specifications (until C++17*)
   noexcept specifier (C++11)
   Exceptions
   throw-expression
   try block
   handler
   Namespaces
   Namespace declaration
   Namespace aliases
   Types
   Fundamental types
   Enumeration types
   Function types
   Class/struct types
   Union types
   Specifiers
   const/volatile
   decltype (C++11)
   auto (C++11)
   constexpr (C++11)
   consteval (C++20)
   constinit (C++20)
   Storage duration specifiers
   Initialization
   Default-initialization
   Value-initialization
   Zero-initialization
   Copy-initialization
   Direct-initialization
   Aggregate initialization
   List-initialization (C++11)
   Constant initialization
   Reference initialization
   Expressions
   Value categories
   Order of evaluation
   Operators
   Operator precedence
   Alternative representations
   Literals
   Boolean - Integer - Floating-point
   Character - String - nullptr (C++11)
   User-defined (C++11)
   Utilities
   Attributes (C++11)
   Types
   typedef declaration
   Type alias declaration (C++11)
   Casts
   Implicit conversions
   static_cast
   const_cast
   Explicit conversions
   dynamic_cast
   reinterpret_cast
   Memory allocation
   new expression
   delete expression
   Classes
   Class declaration
   Constructors
   this pointer
   Access specifiers
   friend specifier
   Class-specific function properties
   Virtual function
   override specifier (C++11)
   final specifier (C++11)
   explicit (C++11)
   static
   Special member functions
   Default constructor
   Copy constructor
   Move constructor (C++11)
   Copy assignment
   Move assignment (C++11)
   Destructor
   Templates
   Class template
   Function template
   Template specialization
   Parameter packs (C++11)
   Miscellaneous
   Inline assembly
   History of C++

   Declarations
   Overview
   Declaration syntax
   decl-specifier-seq
   Declarator
   Conflicting declarations
   Specifiers
   typedef
   inline
   virtual function specifier
   explicit function specifier
   friend
   constexpr
   (C++11)
   consteval
   (C++20)
   constinit
   (C++20)
   Storage class specifiers
   Translation-unit-local (C++20)
   class/struct
   union
   enum
   decltype
   (C++11)
   auto
   (C++11)
   alignas
   (C++11)
   constvolatile
   Pack indexing specifier (C++26)
   Elaborated type specifier
   Attributes (C++11)
   Declarators
   Reference
   Pointer
   Array
   Block declarations
   Simple-declaration
   ->Structured binding declaration (C++17)
   Alias declaration (C++11)
   Namespace alias definition
   using declaration
   using directive
   static_assert declaration (C++11)
   asm declaration
   Opaque enum declaration (C++11)
   Other declarations
   Namespace definition
   Function declaration
   Class template declaration
   Function template declaration
   Explicit template instantiation (C++11)
   Explicit template specialization
   Linkage specification
   Attribute declaration (C++11)
   Empty declaration

   Expressions
   General
   Value categories
   Order of evaluation
   Constant expressions
   Primary expressions
   Lambda expressions (C++11)
   Pack indexing expression (C++26)
   Potentially-evaluated expressions
   Literals
   Integer literals
   Floating-point literals
   Boolean literals
   Character literals
   Escape sequences
   String literals
   Null pointer literal (C++11)
   User-defined literal (C++11)
   Operators
   Assignment operators
   Increment and decrement
   Arithmetic operators
   Logical operators
   Comparison operators
   Member access operators
   Other operators
   new-expression
   delete-expression
   throw-expression
   alignof
   sizeof
   sizeof... (C++11)
   typeid
   noexcept (C++11)
   Fold expressions (C++17)
   Alternative representations of operators
   Precedence and associativity
   Operator overloading
   Default comparisons (C++20)
   Conversions
   Implicit conversions
   Explicit conversions
   Usual arithmetic conversions
   User-defined conversion
   const_cast
   static_cast
   dynamic_cast
   reinterpret_cast

   Templates
   Parameters and arguments
   Class templates
   Function templates
   Class member templates
   Variable templates (C++14)
   Template argument deduction
   Class template argument deduction (C++17)
   Explicit (full) specialization
   Partial specialization
   Dependent names
   Parameter packs (C++11)
      sizeof... (C++11)
      Fold expressions (C++17)
      Pack indexing (C++26)
   SFINAE
   Constraints and concepts (C++20)
   Requires expression (C++20)

   A class template defines a family of classes.

Syntax

   template < parameter-list > class-declaration (1)
   export template < parameter-list > class-declaration (2) (removed in
   C++11)

Explanation

   class-declaration - a class declaration. The class name declared
   becomes a template name.
   parameter-list - a non-empty comma-separated list of the template
   parameters, each of which is either a non-type parameter, a type
   parameter, a template parameter, or a parameter pack of any of those.
   export was an optional modifier which declared the template as exported
   (when used with a class template, it declared all of its members
   exported as well). Files that instantiated exported templates did not
   need to include their definitions: the declaration was sufficient.
   Implementations of export were rare and disagreed with each other on
   details. (until C++11)

Class template instantiation

   A class template by itself is not a type, or an object, or any other
   entity. No code is generated from a source file that contains only
   template definitions. In order for any code to appear, a template must
   be instantiated: the template arguments must be provided so that the
   compiler can generate an actual class (or function, from a function
   template).

Explicit instantiation

   template class-key template-name < argument-list > ; (1)
   extern template class-key template-name < argument-list > ; (2) (since
   C++11)
   class-key - class, struct or union
   1) Explicit instantiation definition
   2) Explicit instantiation declaration

   An explicit instantiation definition forces instantiation of the class,
   struct, or union they refer to. It may appear in the program anywhere
   after the template definition, and for a given argument-list, is only
   allowed to appear once in the entire program, no diagnostic required.

   An explicit instantiation declaration (an extern template) skips
   implicit instantiation step: the code that would otherwise cause an
   implicit instantiation instead uses the explicit instantiation
   definition provided elsewhere (resulting in link errors if no such
   instantiation exists). This can be used to reduce compilation times by
   explicitly declaring a template instantiation in all but one of the
   source files using it, and explicitly defining it in the remaining
   file.
   (since C++11)

   Classes, functions, variables(since C++14), and member template
   specializations can be explicitly instantiated from their templates.
   Member functions, member classes, and static data members of class
   templates can be explicitly instantiated from their member definitions.

   Explicit instantiation can only appear in the enclosing namespace of
   the template, unless it uses qualified-id:
namespace N
{
    template<class T>
    class Y // template definition
    {
        void mf() {}
    };
}

// template class Y<int>; // error: class template Y not visible in the global n
amespace
using N::Y;
// template class Y<int>; // error: explicit instantiation outside
                          // of the namespace of the template
template class N::Y<char*>;       // OK: explicit instantiation
template void N::Y<double>::mf(); // OK: explicit instantiation

   Explicit instantiation has no effect if an explicit specialization
   appeared before for the same set of template arguments.

   Only the declaration is required to be visible when explicitly
   instantiating a function template, a variable template(since C++14), a
   member function or static data member of a class template, or a member
   function template. The complete definition must appear before the
   explicit instantiation of a class template, a member class of a class
   template, or a member class template, unless an explicit specialization
   with the same template arguments appeared before.

   If a function template, variable template(since C++14), member function
   template, or member function or static data member of a class template
   is explicitly instantiated with an explicit instantiation definition,
   the template definition must be present in the same translation unit.

   When an explicit instantiation names a class template specialization,
   it serves as an explicit instantiation of the same kind (declaration or
   definition) of each of its non-inherited non-template members that has
   not been previously explicitly specialized in the translation unit. If
   this explicit instantiation is a definition, it is also an explicit
   instantiation definition only for the members that have been defined at
   this point.

   Explicit instantiation definitions ignore member access specifiers:
   parameter types and return types may be private.

Implicit instantiation

   When code refers to a template in context that requires a completely
   defined type, or when the completeness of the type affects the code,
   and this particular type has not been explicitly instantiated, implicit
   instantiation occurs. For example, when an object of this type is
   constructed, but not when a pointer to this type is constructed.

   This applies to the members of the class template: unless the member is
   used in the program, it is not instantiated, and does not require a
   definition.
template<class T>
struct Z // template definition
{
    void f() {}
    void g(); // never defined
};

template struct Z<double>; // explicit instantiation of Z<double>
Z<int> a;                  // implicit instantiation of Z<int>
Z<char>* p;                // nothing is instantiated here

p->f(); // implicit instantiation of Z<char> and Z<char>::f() occurs here.
        // Z<char>::g() is never needed and never instantiated:
        // it does not have to be defined

   If a class template has been declared, but not defined, at the point of
   instantiation, the instantiation yields an incomplete class type:
template<class T>
class X;    // declaration, not definition

X<char> ch; // error: incomplete type X<char>

   Local classes and any templates used in their members are instantiated
   as part of the instantiation of the entity within which the local class
   or enumeration is declared. (since C++17)

See also

     * template parameters and arguments allow templates to be
       parameterized
     * function template declaration declares a function template
     * template specialization defines an existing template for a specific
       type
     * parameter packs allows the use of lists of types in templates
       (since C++11)

   Retrieved from
   "https://en.cppreference.com/mwiki/index.php?title=cpp/language/class_t
   emplate&oldid=167753"

Navigation

     * Online version
     * Offline version retrieved 2024-06-10 08:17.

     * This page was last modified on 29 December 2023, at 21:35.
     * This page has been accessed 915,808 times.
