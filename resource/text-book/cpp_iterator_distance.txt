std::distance

   From cppreference.com
   < cpp | iterator

   C++
   Compiler support
   Freestanding and hosted
   Language
   Standard library
   Standard library headers
   Named requirements
   Feature test macros (C++20)
   Language support library
   Concepts library (C++20)
   Metaprogramming library (C++11)
   Diagnostics library
   General utilities library
   Strings library
   Containers library
   Iterators library
   Ranges library (C++20)
   Algorithms library
   Numerics library
   Localizations library
   Input/output library
   Filesystem library (C++17)
   Regular expressions library (C++11)
   Concurrency support library (C++11)
   Technical specifications
   Symbols index
   External libraries

   Iterator library
   Iterator concepts
   indirectly_readable
   (C++20)
   indirectly_writable
   (C++20)
   weakly_incrementable
   (C++20)
   incrementable
   (C++20)
   input_or_output_iterator
   (C++20)
   sentinel_for
   (C++20)
   sized_sentinel_for
   (C++20)
   input_iterator
   (C++20)
   output_iterator
   (C++20)
   forward_iterator
   (C++20)
   bidirectional_iterator
   (C++20)
   random_access_iterator
   (C++20)
   contiguous_iterator
   (C++20)
   Iterator primitives
   input_iterator_tagoutput_iterator_tagforward_iterator_tagbidirectional_
   iterator_tagrandom_access_iterator_tagcontiguous_iterator_tag
   (C++20)
   iter_value_titer_difference_titer_reference_titer_const_reference_titer
   _rvalue_reference_titer_common_reference_t
   (C++20)(C++20)(C++20)(C++23)(C++20)(C++20)
   iterator
   (deprecated in C++17)
   iterator_traits
   incrementable_traits
   (C++20)
   indirectly_readable_traits
   (C++20)
   Algorithm concepts and utilities
   Indirect callable concepts
   indirectly_unary_invocableindirectly_regular_unary_invocable
   (C++20)(C++20)
   indirect_unary_predicate
   (C++20)
   indirect_binary_predicate
   (C++20)
   indirect_equivalence_relation
   (C++20)
   indirect_strict_weak_order
   (C++20)
   Common algorithm requirements
   indirectly_movable
   (C++20)
   indirectly_movable_storable
   (C++20)
   indirectly_copyable
   (C++20)
   indirectly_copyable_storable
   (C++20)
   indirectly_swappable
   (C++20)
   indirectly_comparable
   (C++20)
   permutable
   (C++20)
   mergeable
   (C++20)
   sortable
   (C++20)
   Utilities
   indirect_result_t
   (C++20)
   projected
   (C++20)
   projected_value_t
   (C++26)
   Iterator adaptors
   reverse_iterator
   make_reverse_iterator
   (C++14)
   move_iterator
   (C++11)
   make_move_iterator
   (C++11)
   default_sentinel_tdefault_sentinel
   (C++20)(C++20)
   unreachable_sentinel_tunreachable_sentinel
   (C++20)(C++20)
   front_insert_iterator
   back_insert_iterator
   inserter
   insert_iterator
   front_inserter
   back_inserter
   move_sentinel
   (C++20)
   common_iterator
   (C++20)
   counted_iterator
   (C++20)
   basic_const_iterator
   (C++23)
   const_iterator
   (C++23)
   const_sentinel
   (C++23)
   make_const_iterator
   (C++23)
   make_const_sentinel
   (C++23)
   Stream iterators
   istream_iterator

   ostream_iterator
   istreambuf_iterator
   ostreambuf_iterator
   Iterator customization points
   ranges::iter_move
   (C++20)
   ranges::iter_swap
   (C++20)
   Iterator operations
   advance
   distance
   prev
   (C++11)
   next
   (C++11)
   ranges::advance
   (C++20)
   ranges::distance
   (C++20)
   ranges::prev
   (C++20)
   ranges::next
   (C++20)
   Range access
   begincbegin
   (C++11)(C++14)
   rbegincrbegin
   (C++14)(C++14)
   endcend
   (C++11)(C++14)
   rendcrend
   (C++14)(C++14)
   sizessize
   (C++17)(C++20)
   empty
   (C++17)
   data
   (C++17)

   Defined in header <iterator>
   template< class InputIt >

   typename std::iterator_traits<InputIt>::difference_type
       distance( InputIt first, InputIt last );
                               (constexpr since C++17)

   Returns the number of hops from first to last.

   If InputIt is not LegacyRandomAccessIterator, the behavior is undefined
   if last is not reachable from first.

   If InputIt is LegacyRandomAccessIterator, the behavior is undefined if
   first and last are neither reachable from each other.

Parameters

   first - iterator pointing to the first element
   last  - iterator pointing to the end of the range
   Type requirements
   -
   InputIt must meet the requirements of LegacyInputIterator. The
   operation is more efficient if InputIt additionally meets the
   requirements of LegacyRandomAccessIterator.

Return value

   The number of increments needed to go from first to last.

   The value may be negative if random-access iterators are used and first
   is reachable from last.
   (since C++11)

Complexity

   Linear.

   However, if InputIt additionally meets the requirements of
   LegacyRandomAccessIterator, complexity is constant.

Possible implementation

   See also the implementations in libstdc++ and libc++.
   C++98 implementation via tag dispatch, with constexpr removed
namespace detail
{
    template<class It>
    constexpr // required since C++17
    typename std::iterator_traits<It>::difference_type
        do_distance(It first, It last, std::input_iterator_tag)
    {
        typename std::iterator_traits<It>::difference_type result = 0;
        while (first != last)
        {
            ++first;
            ++result;
        }
        return result;
    }

    template<class It>
    constexpr // required since C++17
    typename std::iterator_traits<It>::difference_type
        do_distance(It first, It last, std::random_access_iterator_tag)
    {
        return last - first;
    }
} // namespace detail

template<class It>
constexpr // since C++17
typename std::iterator_traits<It>::difference_type
    distance(It first, It last)
{
    return detail::do_distance(first, last,
                               typename std::iterator_traits<It>::iterator_categ
ory());
}

               C++17 implementation via if constexpr
template<class It>
constexpr typename std::iterator_traits<It>::difference_type
    distance(It first, It last)
{
    using category = typename std::iterator_traits<It>::iterator_category;
    static_assert(std::is_base_of_v<std::input_iterator_tag, category>);

    if constexpr (std::is_base_of_v<std::random_access_iterator_tag, category>)
        return last - first;
    else
    {
        typename std::iterator_traits<It>::difference_type result = 0;
        while (first != last)
        {
            ++first;
            ++result;
        }
        return result;
    }
}

Example

   Run this code
#include <iostream>
#include <iterator>
#include <vector>

int main()
{
    std::vector<int> v{3, 1, 4};
    std::cout << "distance(first, last) = "
              << std::distance(v.begin(), v.end()) << '\n'
              << "distance(last, first) = "
              << std::distance(v.end(), v.begin()) << '\n';
              // the behavior is undefined (until LWG940)

    static constexpr auto il = {3, 1, 4};
    // Since C++17 `distance` can be used in constexpr context.
    static_assert(std::distance(il.begin(), il.end()) == 3);
    static_assert(std::distance(il.end(), il.begin()) == -3);
}

   Output:
distance(first, last) = 3
distance(last, first) = -3

Defect reports

   The following behavior-changing defect reports were applied
   retroactively to previously published C++ standards.
   DR Applied to Behavior as published Correct behavior
   LWG 940 C++98 the wording was unclear for the case where first is
   reachable from last made clear

See also

   advance
   advances an iterator by given distance
   (function template)
   countcount_if
   returns the number of elements satisfying specific criteria
   (function template)
   ranges::distance
   (C++20)
   returns the distance between an iterator and a sentinel, or between the
   beginning and end of a range
   (niebloid)
   Retrieved from
   "https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/distanc
   e&oldid=155668"

Navigation

     * Online version
     * Offline version retrieved 2024-06-10 08:17.

     * This page was last modified on 28 July 2023, at 09:35.
     * This page has been accessed 816,407 times.
