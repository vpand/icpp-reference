std::generator

   From cppreference.com
   < cpp | coroutine

   C++
   Compiler support
   Freestanding and hosted
   Language
   Standard library
   Standard library headers
   Named requirements
   Feature test macros (C++20)
   Language support library
   Concepts library (C++20)
   Metaprogramming library (C++11)
   Diagnostics library
   General utilities library
   Strings library
   Containers library
   Iterators library
   Ranges library (C++20)
   Algorithms library
   Numerics library
   Localizations library
   Input/output library
   Filesystem library (C++17)
   Regular expressions library (C++11)
   Concurrency support library (C++11)
   Technical specifications
   Symbols index
   External libraries

   Utilities library
   Language support
   Type support (basic types, RTTI)
   Library feature-test macros (C++20)
   Dynamic memory management
   Program utilities
   Coroutine support (C++20)
   Variadic functions
   is_constant_evaluated
   (C++20)
   is_within_lifetime
   (C++26)
   initializer_list
   (C++11)
   source_location
   (C++20)
   Debugging support
   is_debugger_present
   (C++26)
   breakpoint_if_debugging
   (C++26)
   breakpoint
   (C++26)
   Three-way comparison
   three_way_comparablethree_way_comparable_with
   (C++20)(C++20)
   strong_ordering
   (C++20)
   weak_ordering
   (C++20)
   partial_ordering
   (C++20)
   common_comparison_category
   (C++20)
   compare_three_way_result
   (C++20)
   compare_three_way
   (C++20)
   strong_order
   (C++20)
   weak_order
   (C++20)
   partial_order
   (C++20)
   compare_strong_order_fallback
   (C++20)
   compare_weak_order_fallback
   (C++20)
   compare_partial_order_fallback
   (C++20)
   is_eqis_ltis_lteq
   (C++20)(C++20)(C++20)
   is_neqis_gtis_gteq
   (C++20)(C++20)(C++20)
   General utilities
   Date and time
   Function objects
   Formatting library (C++20)
   bitset
   hash
   (C++11)
   Relational operators (deprecated in C++20)
   rel_ops::operator!=rel_ops::operator>

   rel_ops::operator<=rel_ops::operator>=
   Integer comparison functions
   cmp_equalcmp_lesscmp_less_than
   (C++20)(C++20)(C++20)
   cmp_not_equalcmp_greatercmp_greater_than
   (C++20)(C++20)(C++20)
   in_range
   (C++20)
   Swap and type operations
   swap
   ranges::swap
   (C++20)
   exchange
   (C++14)
   declval
   (C++11)
   to_underlying
   (C++23)
   forward
   (C++11)
   forward_like
   (C++23)
   move
   (C++11)
   move_if_noexcept
   (C++11)
   as_const
   (C++17)
   Common vocabulary types
   pair
   tuple
   (C++11)
   optional
   (C++17)
   any
   (C++17)
   variant
   (C++17)
   tuple_size
   (C++11)
   tuple_element
   (C++11)
   apply
   (C++17)
   make_from_tuple
   (C++17)
   expected
   (C++23)
   Elementary string conversions
   to_chars
   (C++17)
   from_chars
   (C++17)
   chars_format
   (C++17)
   to_chars_result
   (C++17)
   from_chars_result
   (C++17)

   Coroutine support
   Coroutine traits
   coroutine_traits
   (C++20)
   Coroutine handle
   coroutine_handle
   (C++20)
   No-op coroutines
   noop_coroutine_promise
   (C++20)
   noop_coroutine
   (C++20)
   Trivial awaitables
   suspend_never
   (C++20)
   suspend_always
   (C++20)
   Range generators
   generator
   (C++23)

   Ranges library
   Range access
   begin
   cbegin
   end
   cend
   rbegin
   crbegin
   rend
   crend
   size
   ssize
   data
   cdata
   empty
   Range conversions
   std::from_range_t
   std::from_range
   (C++23)(C++23)
   to
   (C++23)
   Range primitives
   range_size_trange_difference_trange_value_trange_reference_t
   iterator_tconst_iterator_tsentinel_tconst_sentinel_t
   (C++23)(C++23)
   range_const_reference_trange_rvalue_reference_trange_common_reference_t
   (C++23)
   elements_of
   (C++23)
   Dangling iterator handling
   dangling
   borrowed_iterator_t
   borrowed_subrange_t
   Range concepts
   range
   borrowed_range
   sized_range
   constant_range
   (C++23)
   common_range
   view
   viewable_range
   input_range
   output_range
   forward_range
   bidirectional_range
   random_access_range
   contiguous_range
   Views
   view_interface
   subrange
   Range factories
   empty_viewviews::empty
   single_viewviews::single
   iota_viewviews::iota
   repeat_viewviews::repeat
   (C++23)(C++23)
   basic_istream_viewviews::istream
   Range adaptors
   views::all_tviews::all
   ref_view
   owning_view
   as_rvalue_viewviews::as_rvalue
   (C++23)(C++23)
   filter_viewviews::filter
   transform_viewviews::transform
   take_viewviews::take
   take_while_viewviews::take_while
   concat_viewviews::concat
   (C++26)(C++26)
   drop_viewviews::drop
   drop_while_viewviews::drop_while
   join_viewviews::join
   join_with_viewviews::join_with
   (C++23)(C++23)
   lazy_split_viewviews::lazy_split
   split_viewviews::split
   views::counted
   common_viewviews::common
   reverse_viewviews::reverse
   as_const_viewviews::as_const
   (C++23)(C++23)
   elements_viewviews::elements
   keys_viewviews::keys
   values_viewviews::values
   enumerate_viewviews::enumerate
   (C++23)(C++23)
   zip_viewviews::zip
   (C++23)(C++23)
   zip_transform_viewviews::zip_transform
   (C++23)(C++23)
   adjacent_viewviews::adjacent
   (C++23)(C++23)
   views::pairwise
   (C++23)
   adjacent_transform_viewviews::adjacent_transform
   (C++23)(C++23)
   views::pairwise_transform
   (C++23)
   chunk_viewviews::chunk
   (C++23)(C++23)
   slide_viewviews::slide
   (C++23)(C++23)
   chunk_by_viewviews::chunk_by
   (C++23)(C++23)
   stride_viewviews::stride
   (C++23)(C++23)
   cartesian_product_viewviews::cartesian_product
   (C++23)(C++23)
   Range generators
   std::generator
   (C++23)
   Range adaptor objects
   Range adaptor closure objects
   range_adaptor_closure
   (C++23)
   Helper items
   copyable-box
   movable-box
   (until C++23)(C++23)
   simple-view
   non-propagating-cache

   std::generator
   Member functions
   generator::generator
   generator::~generator
   generator::operator=
   generator::begin
   generator::end
   promise_type
   generator::promise_type::get_return_object
   generator::promise_type::initial_suspend
   generator::promise_type::final_suspend
   generator::promise_type::yield_value
   generator::promise_type::return_void
   generator::promise_type::unhandled_exception
   generator::promise_type::operator new
   generator::promise_type::operator delete
   Iterator
   generator::iterator::iterator
   generator::iterator::operator=
   generator::iterator::operator*
   generator::iterator::operator++
   generator::iterator::operator++(int)
   operator==(generator::iterator, std::default_sentinel_t)

   Defined in header <generator>
   template<

       class Ref,
       class V = void,
       class Allocator = void >
   class generator
       : public ranges::view_interface<generator<Ref, V, Allocator>>
   (1)                          (since C++23)
   namespace pmr {

       template< class Ref, class V = void >
       using generator =
           std::generator<Ref, V, std::pmr::polymorphic_allocator<>>;
   }
   (2)                          (since C++23)
   1) The class template std::generator presents a view of the elements
   yielded by the evaluation of a coroutine.
   2) Convenience alias template for the generator using the polymorphic
   allocator.

   A std::generator generates a sequence of elements by repeatedly
   resuming the coroutine from which it was returned. Each time a co_yield
   statement is evaluated, the coroutine produces one element of the
   sequence. When the co_yield statement is of the form co_yield
   ranges::elements_of(rng), each element of the range rng is successively
   produced as an element of the sequence.

   std::generator models view and input_range.

   The behavior of a program that adds a specialization for std::generator
   is undefined.

Template parameters

   Ref - the reference type (ranges::range_reference_t) of the generator.
   If V is void, both the reference type and the value type are inferred
   from Ref
   V - the value type (range_value_t) of the generator, or void
   Allocator - an allocator type or void

   If Allocator is not void, then the behavior is undefined if Allocator
   does not meet the Allocator requirements.

Member types

   Member type Definition
   value (private) std::conditional_t<std::is_void_v<V>,
   std::remove_cvref_t<Ref>, V>;.
   (exposition-only member type*)
   reference (private) std::conditional_t<std::is_void_v<V>, Ref&&, Ref>;.
   (exposition-only member type*)
   yielded std::conditional_t<std::is_reference_v<reference>, reference,
   const reference&>.
   Type requirements
   -
   std::allocator_traits<Allocator>::pointer is a pointer type.
   -
   value is a cv-unqualified object type.
   -
   reference is either a reference type, or a cv-unqualified object type
   that models copy_constructible.
   -
   Let /*RRef*/ denote:std::remove_reference_t</*reference*/>&&, if
   /*reference*/ is a reference type, and /*reference*/ otherwise.
     * std::common_reference_with</*reference*/&&, /*value*/&> is modeled.
     * std::common_reference_with</*reference*/&&, /*RRef*/&&> is modeled.
     * std::common_reference_with</*RRef*/&&, const /*value*/&> is
       modeled.

   The program is ill-formed if any of these type requirements is not
   satisfied.

Member objects

   Member name Definition
   active_ (private)

   Internally, each active instance of std::generator is associated with a
   stack (handled as if by object of type
   std::unique_ptr<std::stack<std::coroutine_handle<>>>).
     * When begin is called, a new stack is created and the generator is
       added to the stack.
     * When co_yield ranges::elements_of(rng) is evaluated in a generator
       body, rng is converted to a generator and added to the stack that
       contains the enclosing generator.
     * When a generator iterator is incremented, the coroutine at the top
       of the associated stack is resumed.
     * When a generator finishes (i.e. when final_suspend is called), it
       is removed from the stack.
       (exposition-only member object*)

   coroutine_ (private) a handle of type
   std::coroutine_handle<promise_type>
   (exposition-only member object*)

Member functions

   (constructor)
   constructs a generator object
   (public member function)
   (destructor)
   effectively destroys the entire stack of yielded generators
   (public member function)
   operator=
   assigns a generator object
   (public member function)
   begin
   resumes the initially suspended coroutine and returns an iterator to
   its handle
   (public member function)
   end
   returns std::default_sentinel
   (public member function)

Inherited from std::ranges::view_interface

   empty
   (C++20)
   returns whether the derived view is empty. Provided if it satisfies
   sized_range or forward_range.
   (public member function of std::ranges::view_interface<D>)
   cbegin
   (C++23)
   returns a constant iterator to the beginning of the range.
   (public member function of std::ranges::view_interface<D>)
   cend
   (C++23)
   returns a sentinel for the constant iterator of the range.
   (public member function of std::ranges::view_interface<D>)
   operator bool
   (C++20)
   returns whether the derived view is not empty. Provided if
   ranges::empty is applicable to it.
   (public member function of std::ranges::view_interface<D>)

Nested classes

   promise_type
   the promise type
   (public member class)
   iterator
   the iterator type
   (exposition-only member class*)

Notes

   Feature-test macro Value Std Feature
   __cpp_lib_generator 202207L (C++23) std::generator - synchronous
   coroutine generator for ranges

Example

   Can be tried in Compiler Explorer
   Run this code
#include <generator>
#include <iostream>

template<typename T>
struct Tree
{
    T value;
    Tree *left{}, *right{};

    std::generator<const T&> traverse_inorder() const
    {
        if (left)
            for (const T& x : left->traverse_inorder())
                co_yield x;

        co_yield value;
        if (right)
            for (const T& x : right->traverse_inorder())
                co_yield x;
    }
};

int main()
{
    Tree<char> tree[]
    {
                                    {'D', tree + 1, tree + 2},
        //                            |
        //            +---------------+----------------+
        //            |                                |
                    {'B', tree + 3, tree + 4},       {'F', tree + 5, tree + 6},
        //            |                                |
        //  +---------+-------------+      +-----------+-------------+
        //  |                       |      |                         |
          {'A'},                  {'C'}, {'E'},                    {'G'}
    };

    for (char x : tree->traverse_inorder())
        std::cout << x << ' ';
    std::cout << '\n';
}

   Output:
A B C D E F G

References

     * C++23 standard (ISO/IEC 14882:2023):

          + 26.8 Range generators [coro.generator]

See also

   noop_coroutine
   (C++20)
   creates a coroutine handle that has no observable effects when resumed
   or destroyed
   (function)
   Retrieved from
   "https://en.cppreference.com/mwiki/index.php?title=cpp/coroutine/genera
   tor&oldid=170892"

Navigation

     * Online version
     * Offline version retrieved 2024-06-10 08:17.

     * This page was last modified on 13 April 2024, at 04:24.
     * This page has been accessed 40,703 times.
