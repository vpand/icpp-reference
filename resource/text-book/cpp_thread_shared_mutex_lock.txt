std::shared_mutex::lock

   From cppreference.com
   < cpp | thread | shared mutex

   C++
   Compiler support
   Freestanding and hosted
   Language
   Standard library
   Standard library headers
   Named requirements
   Feature test macros (C++20)
   Language support library
   Concepts library (C++20)
   Metaprogramming library (C++11)
   Diagnostics library
   General utilities library
   Strings library
   Containers library
   Iterators library
   Ranges library (C++20)
   Algorithms library
   Numerics library
   Localizations library
   Input/output library
   Filesystem library (C++17)
   Regular expressions library (C++11)
   Concurrency support library (C++11)
   Technical specifications
   Symbols index
   External libraries

   Concurrency support library
   Threads
   thread
   (C++11)
   jthread
   (C++20)
   stop_token
   (C++20)
   stop_source
   (C++20)
   stop_callback
   (C++20)
   hardware_destructive_interference_sizehardware_constructive_interferenc
   e_size
   (C++17)(C++17)
   this_thread namespace
   get_id
   (C++11)
   yield
   (C++11)
   sleep_for
   (C++11)
   sleep_until
   (C++11)
   Mutual exclusion
   mutex
   (C++11)
   recursive_mutex
   (C++11)
   shared_mutex
   (C++17)
   timed_mutex
   (C++11)
   recursive_timed_mutex
   (C++11)
   shared_timed_mutex
   (C++14)
   Generic lock management
   lock_guard
   (C++11)
   scoped_lock
   (C++17)
   unique_lock
   (C++11)
   shared_lock
   (C++14)
   defer_lock_ttry_to_lock_tadopt_lock_t
   (C++11)(C++11)(C++11)
   lock
   (C++11)
   try_lock
   (C++11)
   defer_locktry_to_lockadopt_lock
   (C++11)(C++11)(C++11)
   once_flag
   (C++11)
   call_once
   (C++11)
   Condition variables
   condition_variable
   (C++11)
   condition_variable_any
   (C++11)
   notify_all_at_thread_exit
   (C++11)
   cv_status
   (C++11)
   Semaphores
   counting_semaphorebinary_semaphore
   (C++20)(C++20)
   Latches and Barriers
   latch
   (C++20)
   barrier
   (C++20)
   Futures
   promise
   (C++11)
   future
   (C++11)
   shared_future
   (C++11)
   packaged_task
   (C++11)
   async
   (C++11)
   launch
   (C++11)
   future_status
   (C++11)
   future_error
   (C++11)
   future_category
   (C++11)
   future_errc
   (C++11)
   Safe Reclamation
   rcu_obj_base
   (C++26)
   rcu_domain
   (C++26)
   rcu_default_domain
   (C++26)
   rcu_synchronize
   (C++26)
   rcu_barrier
   (C++26)
   rcu_retire
   (C++26)
   Hazard Pointers
   hazard_pointer_obj_base
   (C++26)
   hazard_pointer
   (C++26)
   make_hazard_pointer
   (C++26)
   Atomic types
   atomic
   (C++11)
   atomic_ref
   (C++20)
   atomic_flag
   (C++11)
   Initialization of atomic types
   atomic_init
   (C++11)(deprecated in C++20)
   ATOMIC_VAR_INIT
   (C++11)(deprecated in C++20)
   ATOMIC_FLAG_INIT
   (C++11)
   Memory ordering
   memory_order
   (C++11)
   kill_dependency
   (C++11)
   atomic_thread_fence
   (C++11)
   atomic_signal_fence
   (C++11)
   Free functions for atomic operations
   atomic_storeatomic_store_explicit
   (C++11)(C++11)
   atomic_loadatomic_load_explicit
   (C++11)(C++11)
   atomic_exchangeatomic_exchange_explicit
   (C++11)(C++11)
   atomic_compare_exchange_weakatomic_compare_exchange_weak_explicitatomic
   _compare_exchange_strongatomic_compare_exchange_strong_explicit
   (C++11)(C++11)(C++11)(C++11)
   atomic_fetch_addatomic_fetch_add_explicit
   (C++11)(C++11)
   atomic_fetch_subatomic_fetch_sub_explicit
   (C++11)(C++11)
   atomic_fetch_andatomic_fetch_and_explicit
   (C++11)(C++11)
   atomic_fetch_oratomic_fetch_or_explicit
   (C++11)(C++11)
   atomic_fetch_xoratomic_fetch_xor_explicit
   (C++11)(C++11)
   atomic_fetch_maxatomic_fetch_max_explicit
   (C++26)(C++26)
   atomic_fetch_minatomic_fetch_min_explicit
   (C++26)(C++26)
   atomic_is_lock_free
   (C++11)
   atomic_waitatomic_wait_explicit
   (C++20)(C++20)
   atomic_notify_one
   (C++20)
   atomic_notify_all
   (C++20)
   Free functions for atomic flags
   atomic_flag_test_and_setatomic_flag_test_and_set_explicit
   (C++11)(C++11)
   atomic_flag_clearatomic_flag_clear_explicit
   (C++11)(C++11)
   atomic_flag_testatomic_flag_test_explicit
   (C++20)(C++20)
   atomic_flag_waitatomic_flag_wait_explicit
   (C++20)(C++20)
   atomic_flag_notify_one
   (C++20)
   atomic_flag_notify_all
   (C++20)

   std::shared_mutex
   Member functions
   shared_mutex::shared_mutex
   shared_mutex::~shared_mutex
   Exclusive locking
   shared_mutex::lock
   shared_mutex::try_lock
   shared_mutex::unlock
   Shared locking
   shared_mutex::lock_shared
   shared_mutex::try_lock_shared
   shared_mutex::unlock_shared
   Native handle
   shared_mutex::native_handle

   void lock();
               (since C++17)

   Acquires an exclusive ownership of the shared_mutex. If another thread
   is holding an exclusive lock or a shared lock on the same shared_mutex
   the a call to lock will block execution until all such locks are
   released. While shared_mutex is locked in an exclusive mode, no other
   lock of any kind can also be held.

   If lock is called by a thread that already owns the shared_mutex in any
   mode (exclusive or shared), the behavior is undefined. A prior unlock()
   operation on the same mutex synchronizes-with (as defined in
   std::memory_order) this operation.

Parameters

   (none)

Return value

   (none)

Exceptions

   Throws std::system_error when errors occur, including errors from the
   underlying operating system that would prevent lock from meeting its
   specifications. The mutex is not locked in the case of any exception
   being thrown.

Notes

   lock() is usually not called directly: std::unique_lock,
   std::scoped_lock, and std::lock_guard are used to manage exclusive
   locking.

Example

   Run this code
#include <chrono>
#include <iostream>
#include <mutex>
#include <shared_mutex>
#include <syncstream>
#include <thread>
#include <vector>

std::mutex stream_mutx;
void print(auto const& v)
{
    std::unique_lock<std::mutex> lock(stream_mutx);
    std::cout << std::this_thread::get_id() << " saw: ";
    for (auto e : v)
        std::cout << e << ' ';
    std::cout << '\n';
}

int main()
{
    using namespace std::chrono_literals;
    constexpr int N_READERS = 5;
    constexpr int LAST = -999;

    std::shared_mutex smtx;
    int product = 0;

    auto writer = [&smtx, &product](int start, int end)
    {
        for (int i = start; i < end; ++i)
        {
            auto data = i;
            {
                std::unique_lock<std::shared_mutex> lock(smtx); // better than:
                                                                // smtx.lock();
                product = data;
            }
            std::this_thread::sleep_for(3ms);
        }

        smtx.lock(); // lock manually
        product = LAST;
        smtx.unlock();
    };

    auto reader = [&smtx, &product]
    {
        int data = 0;
        std::vector<int> seen;
        do
        {
            {
                // better to use:
                std::shared_lock lock(smtx); // smtx.lock_shared();
                data = product;
            }                                // smtx.unlock_shared();

            seen.push_back(data);
            std::this_thread::sleep_for(2ms);
        }
        while (data != LAST);

        print(seen);
    };

    std::vector<std::thread> threads;
    threads.emplace_back(writer, 1, 13);
    threads.emplace_back(writer, 42, 52);

    for (int i = 0; i < N_READERS; ++i)
        threads.emplace_back(reader);

    for (auto&& t : threads)
        t.join();
}

   Possible output:
127755840 saw: 43 3 3 4 46 5 6 7 7 8 9 51 10 11 11 12 -999
144541248 saw: 2 44 3 4 46 5 6 7 7 8 9 51 10 11 11 12 -999
110970432 saw: 42 2 3 45 4 5 47 6 7 8 8 9 10 11 11 12 -999
119363136 saw: 42 2 3 4 46 5 6 7 7 8 9 9 10 11 11 12 12 -999
136148544 saw: 2 44 3 4 46 5 6 48 7 8 9 51 10 11 11 12 12 -999

See also

   try_lock
   tries to lock the mutex, returns if the mutex is not available
   (public member function)
   unlock
   unlocks the mutex
   (public member function)
   lock_shared
   locks the mutex for shared ownership, blocks if the mutex is not
   available
   (public member function)
   Retrieved from
   "https://en.cppreference.com/mwiki/index.php?title=cpp/thread/shared_mu
   tex/lock&oldid=156947"

Navigation

     * Online version
     * Offline version retrieved 2024-06-10 08:17.

     * This page was last modified on 17 August 2023, at 10:26.
     * This page has been accessed 39,785 times.
