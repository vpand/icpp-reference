constinit specifier (since C++20)

   From cppreference.com
   < cpp | language

   C++
   Compiler support
   Freestanding and hosted
   Language
   Standard library
   Standard library headers
   Named requirements
   Feature test macros (C++20)
   Language support library
   Concepts library (C++20)
   Metaprogramming library (C++11)
   Diagnostics library
   General utilities library
   Strings library
   Containers library
   Iterators library
   Ranges library (C++20)
   Algorithms library
   Numerics library
   Localizations library
   Input/output library
   Filesystem library (C++17)
   Regular expressions library (C++11)
   Concurrency support library (C++11)
   Technical specifications
   Symbols index
   External libraries

   C++ language
   General topics
   Preprocessor
   Comments
   Keywords
   Escape sequences
   Flow control
   Conditional execution statements
   if
   switch
   Iteration statements (loops)
   for
   range-for (C++11)
   while
   do-while
   Jump statements
   continue - break
   goto - return
   Functions
   Function declaration
   Lambda function expression
   inline specifier
   Dynamic exception specifications (until C++17*)
   noexcept specifier (C++11)
   Exceptions
   throw-expression
   try block
   handler
   Namespaces
   Namespace declaration
   Namespace aliases
   Types
   Fundamental types
   Enumeration types
   Function types
   Class/struct types
   Union types
   Specifiers
   const/volatile
   decltype (C++11)
   auto (C++11)
   constexpr (C++11)
   consteval (C++20)
   constinit (C++20)
   Storage duration specifiers
   Initialization
   Default-initialization
   Value-initialization
   Zero-initialization
   Copy-initialization
   Direct-initialization
   Aggregate initialization
   List-initialization (C++11)
   Constant initialization
   Reference initialization
   Expressions
   Value categories
   Order of evaluation
   Operators
   Operator precedence
   Alternative representations
   Literals
   Boolean - Integer - Floating-point
   Character - String - nullptr (C++11)
   User-defined (C++11)
   Utilities
   Attributes (C++11)
   Types
   typedef declaration
   Type alias declaration (C++11)
   Casts
   Implicit conversions
   static_cast
   const_cast
   Explicit conversions
   dynamic_cast
   reinterpret_cast
   Memory allocation
   new expression
   delete expression
   Classes
   Class declaration
   Constructors
   this pointer
   Access specifiers
   friend specifier
   Class-specific function properties
   Virtual function
   override specifier (C++11)
   final specifier (C++11)
   explicit (C++11)
   static
   Special member functions
   Default constructor
   Copy constructor
   Move constructor (C++11)
   Copy assignment
   Move assignment (C++11)
   Destructor
   Templates
   Class template
   Function template
   Template specialization
   Parameter packs (C++11)
   Miscellaneous
   Inline assembly
   History of C++

   Declarations
   Overview
   Declaration syntax
   decl-specifier-seq
   Declarator
   Conflicting declarations
   Specifiers
   typedef
   inline
   virtual function specifier
   explicit function specifier
   friend
   constexpr
   (C++11)
   consteval
   (C++20)
   constinit
   (C++20)
   Storage class specifiers
   Translation-unit-local (C++20)
   class/struct
   union
   enum
   decltype
   (C++11)
   auto
   (C++11)
   alignas
   (C++11)
   constvolatile
   Pack indexing specifier (C++26)
   Elaborated type specifier
   Attributes (C++11)
   Declarators
   Reference
   Pointer
   Array
   Block declarations
   Simple-declaration
   ->Structured binding declaration (C++17)
   Alias declaration (C++11)
   Namespace alias definition
   using declaration
   using directive
   static_assert declaration (C++11)
   asm declaration
   Opaque enum declaration (C++11)
   Other declarations
   Namespace definition
   Function declaration
   Class template declaration
   Function template declaration
   Explicit template instantiation (C++11)
   Explicit template specialization
   Linkage specification
   Attribute declaration (C++11)
   Empty declaration

          + constinit - asserts that a variable has static initialization,
            i.e. zero initialization and constant initialization,
            otherwise the program is ill-formed.

Explanation

   The constinit specifier declares a variable with static or thread
   storage duration. If a variable is declared with constinit, its
   initializing declaration must be applied with constinit. If a variable
   declared with constinit has dynamic initialization (even if it is
   performed as static initialization), the program is ill-formed. If no
   constinit declaration is reachable at the point of the initializing
   declaration, the program is ill-formed, no diagnostic required.

   constinit cannot be used together with constexpr. When the declared
   variable is a reference, constinit is equivalent to constexpr. When the
   declared variable is an object, constexpr mandates that the object must
   have static initialization and constant destruction and makes the
   object const-qualified, however, constinit does not mandate constant
   destruction and const-qualification. As a result, an object of a type
   which has constexpr constructors and no constexpr destructor (e.g.
   std::shared_ptr<T>) might be declared with constinit but not constexpr.
const char* g() { return "dynamic initialization"; }
constexpr const char* f(bool p) { return p ? "constant initializer" : g(); }

constinit const char* c = f(true);     // OK
// constinit const char* d = f(false); // error

   constinit can also be used in a non-initializing declaration to tell
   the compiler that a thread_local variable is already initialized,
   reducing overhead that would otherwise be incurred by a hidden guard
   variable.
extern thread_local constinit int x;
int f() { return x; } // no check of a guard variable needed

Notes

   Feature-test macro  Value    Std    Feature
   __cpp_constinit    201907L (C++20) constinit

Keywords

   constinit

Example

   This section is incomplete
   Reason: no example

Defect reports

   The following behavior-changing defect reports were applied
   retroactively to previously published C++ standards.
   DR Applied to Behavior as published Correct behavior
   CWG 2543 C++20 the behavior was unclear if the variable declared with
   constinit
   is dynamically initialized as part of static initialization the program
   is ill-
   formed in this case

See also

   consteval specifier(C++20) specifies that a function is an immediate
   function, that is, every call to the function must be in a constant
   evaluation
   constexpr specifier(C++11) specifies that the value of a variable or
   function can be computed at compile time
   constant expression defines an expression that can be evaluated at
   compile time
   constant initialization sets the initial values of the static variables
   to a compile-time constant
   zero initialization sets the initial value of an object to zero
   Retrieved from
   "https://en.cppreference.com/mwiki/index.php?title=cpp/language/constin
   it&oldid=159194"

Navigation

     * Online version
     * Offline version retrieved 2024-06-10 08:17.

     * This page was last modified on 16 September 2023, at 09:48.
     * This page has been accessed 131,995 times.
