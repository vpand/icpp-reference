std::variant<Types...>::valueless_by_exception

   From cppreference.com
   < cpp | utility | variant

   C++
   Compiler support
   Freestanding and hosted
   Language
   Standard library
   Standard library headers
   Named requirements
   Feature test macros (C++20)
   Language support library
   Concepts library (C++20)
   Metaprogramming library (C++11)
   Diagnostics library
   General utilities library
   Strings library
   Containers library
   Iterators library
   Ranges library (C++20)
   Algorithms library
   Numerics library
   Localizations library
   Input/output library
   Filesystem library (C++17)
   Regular expressions library (C++11)
   Concurrency support library (C++11)
   Technical specifications
   Symbols index
   External libraries

   Utilities library
   Language support
   Type support (basic types, RTTI)
   Library feature-test macros (C++20)
   Dynamic memory management
   Program utilities
   Coroutine support (C++20)
   Variadic functions
   is_constant_evaluated
   (C++20)
   is_within_lifetime
   (C++26)
   initializer_list
   (C++11)
   source_location
   (C++20)
   Debugging support
   is_debugger_present
   (C++26)
   breakpoint_if_debugging
   (C++26)
   breakpoint
   (C++26)
   Three-way comparison
   three_way_comparablethree_way_comparable_with
   (C++20)(C++20)
   strong_ordering
   (C++20)
   weak_ordering
   (C++20)
   partial_ordering
   (C++20)
   common_comparison_category
   (C++20)
   compare_three_way_result
   (C++20)
   compare_three_way
   (C++20)
   strong_order
   (C++20)
   weak_order
   (C++20)
   partial_order
   (C++20)
   compare_strong_order_fallback
   (C++20)
   compare_weak_order_fallback
   (C++20)
   compare_partial_order_fallback
   (C++20)
   is_eqis_ltis_lteq
   (C++20)(C++20)(C++20)
   is_neqis_gtis_gteq
   (C++20)(C++20)(C++20)
   General utilities
   Date and time
   Function objects
   Formatting library (C++20)
   bitset
   hash
   (C++11)
   Relational operators (deprecated in C++20)
   rel_ops::operator!=rel_ops::operator>

   rel_ops::operator<=rel_ops::operator>=
   Integer comparison functions
   cmp_equalcmp_lesscmp_less_than
   (C++20)(C++20)(C++20)
   cmp_not_equalcmp_greatercmp_greater_than
   (C++20)(C++20)(C++20)
   in_range
   (C++20)
   Swap and type operations
   swap
   ranges::swap
   (C++20)
   exchange
   (C++14)
   declval
   (C++11)
   to_underlying
   (C++23)
   forward
   (C++11)
   forward_like
   (C++23)
   move
   (C++11)
   move_if_noexcept
   (C++11)
   as_const
   (C++17)
   Common vocabulary types
   pair
   tuple
   (C++11)
   optional
   (C++17)
   any
   (C++17)
   variant
   (C++17)
   tuple_size
   (C++11)
   tuple_element
   (C++11)
   apply
   (C++17)
   make_from_tuple
   (C++17)
   expected
   (C++23)
   Elementary string conversions
   to_chars
   (C++17)
   from_chars
   (C++17)
   chars_format
   (C++17)
   to_chars_result
   (C++17)
   from_chars_result
   (C++17)

   std::variant
   Member functions
   variant::variant
   variant::~variant
   variant::operator=
   Observers
   variant::index
   variant::valueless_by_exception
   Modifiers
   variant::emplace
   variant::swap
   Visitation
   variant::visit
   (C++26)
   Non-member functions
   visit
   holds_alternative
   get(std::variant)
   get_if
   operator==operator!=operator<operator<=operator>operator>=operator<=>
   (C++20)
   swap(std::variant)
   Helper classes
   monostate
   bad_variant_access
   variant_size
   variant_alternative
   hash<std::variant>
   Helper objects
   variant_npos

   constexpr bool valueless_by_exception() const noexcept;
                                                          (since C++17)

   Returns false if and only if the variant holds a value.

Notes

   A variant may become valueless in the following situations:
     * (guaranteed) an exception is thrown during the initialization of
       the contained value during move assignment
     * (optionally) an exception is thrown during the initialization of
       the contained value during copy assignment
     * (optionally) an exception is thrown when initializing the contained
       value during a type-changing assignment
     * (optionally) an exception is thrown when initializing the contained
       value during a type-changing emplace

   Since variant is never permitted to allocate dynamic memory, previous
   value cannot be retained in these situations. The situations marked
   "optionally" can be worked around by implementations that first
   construct the new value on the stack and then move it into the variant
   (provided non-throwing move).

   This applies even to variants of non-class types:
struct S {
    operator int() { throw 42; }
};
std::variant<float, int> v{12.f}; // OK
v.emplace<1>(S()); // v may be valueless

   A variant that is valueless by exception is treated as being in an
   invalid state: index returns variant_npos, get and visit throw
   bad_variant_access.

Example

   Run this code
#include <cassert>
#include <iostream>
#include <stdexcept>
#include <string>
#include <variant>

struct Demo {
    Demo(int) {}
    Demo(const Demo&) { throw std::domain_error("copy ctor"); }
    Demo& operator= (const Demo&) = default;
};

int main()
{
    std::variant<std::string, Demo> var{"str"};
    assert(var.index() == 0);
    assert(std::get<0>(var) == "str");
    assert(var.valueless_by_exception() == false);

    try {
        var = Demo{555};
    } catch (const std::domain_error& ex) {
        std::cout << "1) Exception: " << ex.what() << '\n';
    }
    assert(var.index() == std::variant_npos);
    assert(var.valueless_by_exception() == true);

    // Now the var is "valueless" which is an invalid state caused
    // by an exception raised in the process of type-changing assignment.

    try {
        std::get<1>(var);
    } catch (const std::bad_variant_access& ex) {
        std::cout << "2) Exception: " << ex.what() << '\n';
    }

    var = "str2";
    assert(var.index() == 0);
    assert(std::get<0>(var) == "str2");
    assert(var.valueless_by_exception() == false);
}

   Possible output:
1) Exception: copy ctor
2) Exception: std::get: variant is valueless

See also

   get(std::variant)
   (C++17)
   reads the value of the variant given the index or the type (if the type
   is unique), throws on error
   (function template)
   index
   returns the zero-based index of the alternative held by the variant
   (public member function)
   bad_variant_access
   (C++17)
   exception thrown on invalid accesses to the value of a variant
   (class)
   Retrieved from
   "https://en.cppreference.com/mwiki/index.php?title=cpp/utility/variant/
   valueless_by_exception&oldid=149650"

Navigation

     * Online version
     * Offline version retrieved 2024-06-10 08:17.

     * This page was last modified on 24 March 2023, at 03:23.
     * This page has been accessed 75,416 times.
