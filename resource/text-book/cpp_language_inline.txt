inline specifier

   From cppreference.com
   < cpp | language

   C++
   Compiler support
   Freestanding and hosted
   Language
   Standard library
   Standard library headers
   Named requirements
   Feature test macros (C++20)
   Language support library
   Concepts library (C++20)
   Metaprogramming library (C++11)
   Diagnostics library
   General utilities library
   Strings library
   Containers library
   Iterators library
   Ranges library (C++20)
   Algorithms library
   Numerics library
   Localizations library
   Input/output library
   Filesystem library (C++17)
   Regular expressions library (C++11)
   Concurrency support library (C++11)
   Technical specifications
   Symbols index
   External libraries

   C++ language
   General topics
   Preprocessor
   Comments
   Keywords
   Escape sequences
   Flow control
   Conditional execution statements
   if
   switch
   Iteration statements (loops)
   for
   range-for (C++11)
   while
   do-while
   Jump statements
   continue - break
   goto - return
   Functions
   Function declaration
   Lambda function expression
   inline specifier
   Dynamic exception specifications (until C++17*)
   noexcept specifier (C++11)
   Exceptions
   throw-expression
   try block
   handler
   Namespaces
   Namespace declaration
   Namespace aliases
   Types
   Fundamental types
   Enumeration types
   Function types
   Class/struct types
   Union types
   Specifiers
   const/volatile
   decltype (C++11)
   auto (C++11)
   constexpr (C++11)
   consteval (C++20)
   constinit (C++20)
   Storage duration specifiers
   Initialization
   Default-initialization
   Value-initialization
   Zero-initialization
   Copy-initialization
   Direct-initialization
   Aggregate initialization
   List-initialization (C++11)
   Constant initialization
   Reference initialization
   Expressions
   Value categories
   Order of evaluation
   Operators
   Operator precedence
   Alternative representations
   Literals
   Boolean - Integer - Floating-point
   Character - String - nullptr (C++11)
   User-defined (C++11)
   Utilities
   Attributes (C++11)
   Types
   typedef declaration
   Type alias declaration (C++11)
   Casts
   Implicit conversions
   static_cast
   const_cast
   Explicit conversions
   dynamic_cast
   reinterpret_cast
   Memory allocation
   new expression
   delete expression
   Classes
   Class declaration
   Constructors
   this pointer
   Access specifiers
   friend specifier
   Class-specific function properties
   Virtual function
   override specifier (C++11)
   final specifier (C++11)
   explicit (C++11)
   static
   Special member functions
   Default constructor
   Copy constructor
   Move constructor (C++11)
   Copy assignment
   Move assignment (C++11)
   Destructor
   Templates
   Class template
   Function template
   Template specialization
   Parameter packs (C++11)
   Miscellaneous
   Inline assembly
   History of C++

   Declarations
   Overview
   Declaration syntax
   decl-specifier-seq
   Declarator
   Conflicting declarations
   Specifiers
   typedef
   inline
   virtual function specifier
   explicit function specifier
   friend
   constexpr
   (C++11)
   consteval
   (C++20)
   constinit
   (C++20)
   Storage class specifiers
   Translation-unit-local (C++20)
   class/struct
   union
   enum
   decltype
   (C++11)
   auto
   (C++11)
   alignas
   (C++11)
   constvolatile
   Pack indexing specifier (C++26)
   Elaborated type specifier
   Attributes (C++11)
   Declarators
   Reference
   Pointer
   Array
   Block declarations
   Simple-declaration
   ->Structured binding declaration (C++17)
   Alias declaration (C++11)
   Namespace alias definition
   using declaration
   using directive
   static_assert declaration (C++11)
   asm declaration
   Opaque enum declaration (C++11)
   Other declarations
   Namespace definition
   Function declaration
   Class template declaration
   Function template declaration
   Explicit template instantiation (C++11)
   Explicit template specialization
   Linkage specification
   Attribute declaration (C++11)
   Empty declaration

   The inline specifier, when used in a function's decl-specifier-seq,
   declares the function to be an inline function.

   A function defined entirely inside a class/struct/union definition,
   whether it's a member function or a non-member friend function, is
   implicitly an inline function unless it is attached to a named
   module(since C++20).

   A function declared constexpr or consteval(since C++20) on its first
   declaration is implicitly an inline function.

   A deleted function is implicitly an inline function: its (deleted)
   definition can appear in more than one translation unit.
   (since C++11)

   The inline specifier, when used in a decl-specifier-seq of a variable
   with static storage duration (static class member or namespace-scope
   variable), declares the variable to be an inline variable.

   A static data member declared constexpr on its first declaration is
   implicitly an inline variable.
   (since C++17)

Explanation

   An inline function or inline variable(since C++17) has the following
   properties:
     * The definition of an inline function or variable(since C++17) must
       be reachable in the translation unit where it is accessed (not
       necessarily before the point of access).
     * An inline function or variable(since C++17) with external linkage
       (e.g. not declared static) has the following additional properties:

          + There may be more than one definition of an inline function or
            variable(since C++17) in the program as long as each
            definition appears in a different translation unit and (for
            non-static inline functions and variables(since C++17)) all
            definitions are identical. For example, an inline function or
            an inline variable(since C++17) may be defined in a header
            file that is included in multiple source files.
          + It must be declared inline in every translation unit.
          + It has the same address in every translation unit.

   In an inline function,
     * Function-local static objects in all function definitions are
       shared across all translation units (they all refer to the same
       object defined in one translation unit).
     * Types defined in all function definitions are also the same in all
       translation units.

   Inline const variables at namespace scope have external linkage by
   default (unlike the non-inline non-volatile const-qualified variables).
   (since C++17)

   The original intent of the inline keyword was to serve as an indicator
   to the optimizer that inline substitution of a function is preferred
   over function call, that is, instead of executing the function call CPU
   instruction to transfer control to the function body, a copy of the
   function body is executed without generating the call. This avoids
   overhead created by the function call (passing the arguments and
   retrieving the result) but it may result in a larger executable as the
   code for the function has to be repeated multiple times.

   Since inline substitution is unobservable in the standard semantics,
   compilers are free to use inline substitution for any function that's
   not marked inline, and are free to generate function calls to any
   function marked inline. Those optimization choices do not change the
   rules regarding multiple definitions and shared statics listed above.

   Because the meaning of the keyword inline for functions came to mean
   "multiple definitions are permitted" rather than "inlining is
   preferred" since C++98, that meaning was extended to variables.
   (since C++17)

Notes

   If an inline function or variable(since C++17) with external linkage is
   defined differently in different translation units, the program is
   ill-formed, no diagnostic required.

   The inline specifier cannot be used with a function or variable(since
   C++17) declaration at block scope (inside another function).

   The inline specifier cannot re-declare a function or variable(since
   C++17) that was already defined in the translation unit as non-inline.

   The implicitly-generated member functions and any member function
   declared as defaulted on its first declaration are inline just like any
   other function defined inside a class definition.

   If an inline function is declared in different translation units, the
   accumulated sets of default arguments must be the same at the end of
   each translation unit.

   In C, inline functions do not have to be declared inline in every
   translation unit (at most one may be non-inline or extern inline), the
   function definitions do not have to be identical (but the behavior of
   the program is unspecified if it depends on which one is called), and
   the function-local statics are distinct between different definitions
   of the same function.

   See static data members for additional rules about inline static
   members.

   Inline variables eliminate the main obstacle to packaging C++ code as
   header-only libraries.
   (since C++17)
     Feature-test macro    Value    Std       Feature
   __cpp_inline_variables 201606L (C++17) Inline variables

Example

   Header "example.h":
#ifndef EXAMPLE_H
#define EXAMPLE_H

#include <atomic>

// function included in multiple source files must be inline
inline int sum(int a, int b)
{
    return a + b;
}

// variable with external linkage included in multiple source files must be inli
ne
inline std::atomic<int> counter(0);

#endif

   Source file #1:
#include "example.h"

int a()
{
    ++counter;
    return sum(1, 2);
}

   Source file #2:
#include "example.h"

int b()
{
    ++counter;
    return sum(3, 4);
}

Defect reports

   The following behavior-changing defect reports were applied
   retroactively to previously published C++ standards.
   DR Applied to Behavior as published Correct behavior
   CWG 281 C++98 a friend function declaration could use the inline
   specifier
   even if the friended function is not an inline function prohibit such
   uses
   CWG 317 C++98 a function could be declared inline even if it has a
   non-inline
   definition in the same translation unit before the declaration the
   program is ill-
   formed in this case
   CWG 765 C++98 a type defined in an inline function might
   be different in different translation units such types are the same
   in all translation units
   CWG 1823 C++98 string literals in all definitions of an inline
   function were shared across all translation units the requirement is
   removed due to
   consistency and implementations
   CWG 2531 C++17 a static data member could be implicitly inline even if
   it was not declared constexpr on its first declaration it is not
   implicitly
   inline in this case

See also

   Retrieved from
   "https://en.cppreference.com/mwiki/index.php?title=cpp/language/inline&
   oldid=171572"

Navigation

     * Online version
     * Offline version retrieved 2024-06-10 08:17.

     * This page was last modified on 7 May 2024, at 06:47.
     * This page has been accessed 764,341 times.
