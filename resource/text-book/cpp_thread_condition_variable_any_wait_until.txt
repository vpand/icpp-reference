std::condition_variable_any::wait_until

   From cppreference.com
   < cpp | thread | condition variable any

   C++
   Compiler support
   Freestanding and hosted
   Language
   Standard library
   Standard library headers
   Named requirements
   Feature test macros (C++20)
   Language support library
   Concepts library (C++20)
   Metaprogramming library (C++11)
   Diagnostics library
   General utilities library
   Strings library
   Containers library
   Iterators library
   Ranges library (C++20)
   Algorithms library
   Numerics library
   Localizations library
   Input/output library
   Filesystem library (C++17)
   Regular expressions library (C++11)
   Concurrency support library (C++11)
   Technical specifications
   Symbols index
   External libraries

   Concurrency support library
   Threads
   thread
   (C++11)
   jthread
   (C++20)
   stop_token
   (C++20)
   stop_source
   (C++20)
   stop_callback
   (C++20)
   hardware_destructive_interference_sizehardware_constructive_interferenc
   e_size
   (C++17)(C++17)
   this_thread namespace
   get_id
   (C++11)
   yield
   (C++11)
   sleep_for
   (C++11)
   sleep_until
   (C++11)
   Mutual exclusion
   mutex
   (C++11)
   recursive_mutex
   (C++11)
   shared_mutex
   (C++17)
   timed_mutex
   (C++11)
   recursive_timed_mutex
   (C++11)
   shared_timed_mutex
   (C++14)
   Generic lock management
   lock_guard
   (C++11)
   scoped_lock
   (C++17)
   unique_lock
   (C++11)
   shared_lock
   (C++14)
   defer_lock_ttry_to_lock_tadopt_lock_t
   (C++11)(C++11)(C++11)
   lock
   (C++11)
   try_lock
   (C++11)
   defer_locktry_to_lockadopt_lock
   (C++11)(C++11)(C++11)
   once_flag
   (C++11)
   call_once
   (C++11)
   Condition variables
   condition_variable
   (C++11)
   condition_variable_any
   (C++11)
   notify_all_at_thread_exit
   (C++11)
   cv_status
   (C++11)
   Semaphores
   counting_semaphorebinary_semaphore
   (C++20)(C++20)
   Latches and Barriers
   latch
   (C++20)
   barrier
   (C++20)
   Futures
   promise
   (C++11)
   future
   (C++11)
   shared_future
   (C++11)
   packaged_task
   (C++11)
   async
   (C++11)
   launch
   (C++11)
   future_status
   (C++11)
   future_error
   (C++11)
   future_category
   (C++11)
   future_errc
   (C++11)
   Safe Reclamation
   rcu_obj_base
   (C++26)
   rcu_domain
   (C++26)
   rcu_default_domain
   (C++26)
   rcu_synchronize
   (C++26)
   rcu_barrier
   (C++26)
   rcu_retire
   (C++26)
   Hazard Pointers
   hazard_pointer_obj_base
   (C++26)
   hazard_pointer
   (C++26)
   make_hazard_pointer
   (C++26)
   Atomic types
   atomic
   (C++11)
   atomic_ref
   (C++20)
   atomic_flag
   (C++11)
   Initialization of atomic types
   atomic_init
   (C++11)(deprecated in C++20)
   ATOMIC_VAR_INIT
   (C++11)(deprecated in C++20)
   ATOMIC_FLAG_INIT
   (C++11)
   Memory ordering
   memory_order
   (C++11)
   kill_dependency
   (C++11)
   atomic_thread_fence
   (C++11)
   atomic_signal_fence
   (C++11)
   Free functions for atomic operations
   atomic_storeatomic_store_explicit
   (C++11)(C++11)
   atomic_loadatomic_load_explicit
   (C++11)(C++11)
   atomic_exchangeatomic_exchange_explicit
   (C++11)(C++11)
   atomic_compare_exchange_weakatomic_compare_exchange_weak_explicitatomic
   _compare_exchange_strongatomic_compare_exchange_strong_explicit
   (C++11)(C++11)(C++11)(C++11)
   atomic_fetch_addatomic_fetch_add_explicit
   (C++11)(C++11)
   atomic_fetch_subatomic_fetch_sub_explicit
   (C++11)(C++11)
   atomic_fetch_andatomic_fetch_and_explicit
   (C++11)(C++11)
   atomic_fetch_oratomic_fetch_or_explicit
   (C++11)(C++11)
   atomic_fetch_xoratomic_fetch_xor_explicit
   (C++11)(C++11)
   atomic_fetch_maxatomic_fetch_max_explicit
   (C++26)(C++26)
   atomic_fetch_minatomic_fetch_min_explicit
   (C++26)(C++26)
   atomic_is_lock_free
   (C++11)
   atomic_waitatomic_wait_explicit
   (C++20)(C++20)
   atomic_notify_one
   (C++20)
   atomic_notify_all
   (C++20)
   Free functions for atomic flags
   atomic_flag_test_and_setatomic_flag_test_and_set_explicit
   (C++11)(C++11)
   atomic_flag_clearatomic_flag_clear_explicit
   (C++11)(C++11)
   atomic_flag_testatomic_flag_test_explicit
   (C++20)(C++20)
   atomic_flag_waitatomic_flag_wait_explicit
   (C++20)(C++20)
   atomic_flag_notify_one
   (C++20)
   atomic_flag_notify_all
   (C++20)

   std::condition_variable_any
   Member functions
   condition_variable_any::condition_variable_any
   condition_variable_any::~condition_variable_any
   Notification
   condition_variable_any::notify_one
   condition_variable_any::notify_all
   Waiting
   condition_variable_any::wait
   condition_variable_any::wait_for
   condition_variable_any::wait_until

   template< class Lock, class Clock, class Duration >

   std::cv_status
       wait_until( Lock& lock,
                   const std::chrono::time_point<Clock, Duration>&
   abs_time );
   (1) (since C++11)
   template< class Lock, class Clock, class Duration, class Predicate >

   bool wait_until( Lock& lock,
                    const std::chrono::time_point<Clock, Duration>&
   abs_time,
                    Predicate pred );
   (2) (since C++11)
   template< class Lock, class Clock, class Duration, class Predicate >

   bool wait_until( Lock& lock, std::stop_token stoken,
                    const std::chrono::time_point<Clock, Duration>&
   abs_time,
                    Predicate pred );
   (3) (since C++20)

   wait_until causes the current thread to block until the condition
   variable is notified, the given duration has been elapsed, or a
   spurious wakeup occurs. pred can be optionally provided to detect
   spurious wakeup.
   1) Atomically calls lock.unlock() and blocks on *this.
   The thread will be unblocked when notify_all() or notify_one() is
   executed, or abs_time is reached. It may also be unblocked spuriously.
   When unblocked, calls lock.lock() (possibly blocking on the lock), then
   returns.
   2,3) Waiting for a specific condition to become true, can be used to
   ignore spurious awakenings.
   2) Equivalent to while (!pred())
       if (wait_until(lock, abs_time) == std::cv_status::timeout)
           return pred();
   return true;.
   3) Registers *this for the duration of this call, to be notified if a
   stop request is made on stoken's associated stop-state; it is then
   equivalent to while (!stoken.stop_requested())
   {
       if (pred())
           return true;
       if (wait_until(lock, abs_time) == std::cv_status::timeout)
           return pred();
   }
   return pred();.

   Right after wait_until returns, lock is locked by the calling thread.
   If this postcondition cannot be satisfied^[1], calls std::terminate.
    1. ^| This can happen if the re-locking of the mutex throws an
       exception.

Parameters

   lock     - an lock which must be locked by the calling thread
   stoken   - a stop token to register interruption for
   abs_time - the time point where waiting expires
   pred     - the predicate to check whether the waiting can be completed
   Type requirements
   -
   Lock must meet the requirements of BasicLockable.
   -
   Predicate must meet the requirements of FunctionObject.

Return value

   1) std::cv_status::timeout if abs_time has been reached, otherwise
   std::cv_status::no_timeout.
   2,3) The latest result of pred() before returning to the caller.

Exceptions

   1) Timeout-related exceptions.
   2,3) Timeout-related exceptions, and any exception thrown by pred.

Notes

   The standard recommends that the clock tied to abs_time be used to
   measure time; that clock is not required to be a monotonic clock. There
   are no guarantees regarding the behavior of this function if the clock
   is adjusted discontinuously, but the existing implementations convert
   abs_time from Clock to std::chrono::system_clock and delegate to POSIX
   pthread_cond_timedwait so that the wait honors adjustments to the
   system clock, but not to the user-provided Clock. In any case, the
   function also may wait for longer than until after abs_time has been
   reached due to scheduling or resource contention delays.

   Even if the clock in use is std::chrono::steady_clock or another
   monotonic clock, a system clock adjustment may induce a spurious
   wakeup.

   The effects of notify_one()/notify_all() and each of the three atomic
   parts of wait()/wait_for()/wait_until() (unlock+wait, wakeup, and lock)
   take place in a single total order that can be viewed as modification
   order of an atomic variable: the order is specific to this individual
   condition variable. This makes it impossible for notify_one() to, for
   example, be delayed and unblock a thread that started waiting just
   after the call to notify_one() was made.

Example

   Run this code
#include <chrono>
#include <condition_variable>
#include <iostream>
#include <thread>

std::condition_variable_any cv;
std::mutex cv_m; // This mutex is used for three purposes:
                 // 1) to synchronize accesses to i
                 // 2) to synchronize accesses to std::cerr
                 // 3) for the condition variable cv
int i = 0;

void waits()
{
    std::unique_lock<std::mutex> lk(cv_m);
    std::cerr << "Waiting... \n";
    cv.wait(lk, []{ return i == 1; });
    std::cerr << "...finished waiting. i == 1\n";
}

void signals()
{
    std::this_thread::sleep_for(std::chrono::seconds(1));
    {
        std::lock_guard<std::mutex> lk(cv_m);
        std::cerr << "Notifying...\n";
    }
    cv.notify_all();

    std::this_thread::sleep_for(std::chrono::seconds(1));

    {
        std::lock_guard<std::mutex> lk(cv_m);
        i = 1;
        std::cerr << "Notifying again...\n";
    }
    cv.notify_all();
}

int main()
{
    std::thread t1(waits), t2(waits), t3(waits), t4(signals);
    t1.join();
    t2.join();
    t3.join();
    t4.join();
}

   Possible output:
Waiting...
Waiting...
Waiting...
Notifying...
Notifying again...
...finished waiting. i == 1
...finished waiting. i == 1
...finished waiting. i == 1

Defect reports

   The following behavior-changing defect reports were applied
   retroactively to previously published C++ standards.
   DR Applied to Behavior as published Correct behavior
   LWG 2093 C++11 timeout-related exceptions were missing in the
   specification mentions these exceptions
   LWG 2135 C++11 the behavior was unclear if lock.lock() throws an
   exception calls std::terminate in this case

See also

   wait
   blocks the current thread until the condition variable is awakened
   (public member function)
   wait_until
   blocks the current thread until the condition variable is awakened or
   until specified time point has been reached
   (public member function)
   Retrieved from
   "https://en.cppreference.com/mwiki/index.php?title=cpp/thread/condition
   _variable_any/wait_until&oldid=170110"

Navigation

     * Online version
     * Offline version retrieved 2024-06-10 08:17.

     * This page was last modified on 7 March 2024, at 22:43.
     * This page has been accessed 24,816 times.
