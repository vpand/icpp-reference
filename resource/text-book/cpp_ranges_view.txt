std::ranges::view, std::ranges::enable_view, std::ranges::view_base

   From cppreference.com
   < cpp | ranges

   C++
   Compiler support
   Freestanding and hosted
   Language
   Standard library
   Standard library headers
   Named requirements
   Feature test macros (C++20)
   Language support library
   Concepts library (C++20)
   Metaprogramming library (C++11)
   Diagnostics library
   General utilities library
   Strings library
   Containers library
   Iterators library
   Ranges library (C++20)
   Algorithms library
   Numerics library
   Localizations library
   Input/output library
   Filesystem library (C++17)
   Regular expressions library (C++11)
   Concurrency support library (C++11)
   Technical specifications
   Symbols index
   External libraries

   Ranges library
   Range access
   begin
   cbegin
   end
   cend
   rbegin
   crbegin
   rend
   crend
   size
   ssize
   data
   cdata
   empty
   Range conversions
   std::from_range_t
   std::from_range
   (C++23)(C++23)
   to
   (C++23)
   Range primitives
   range_size_trange_difference_trange_value_trange_reference_t
   iterator_tconst_iterator_tsentinel_tconst_sentinel_t
   (C++23)(C++23)
   range_const_reference_trange_rvalue_reference_trange_common_reference_t
   (C++23)
   elements_of
   (C++23)
   Dangling iterator handling
   dangling
   borrowed_iterator_t
   borrowed_subrange_t
   Range concepts
   range
   borrowed_range
   sized_range
   constant_range
   (C++23)
   common_range
   view
   viewable_range
   input_range
   output_range
   forward_range
   bidirectional_range
   random_access_range
   contiguous_range
   Views
   view_interface
   subrange
   Range factories
   empty_viewviews::empty
   single_viewviews::single
   iota_viewviews::iota
   repeat_viewviews::repeat
   (C++23)(C++23)
   basic_istream_viewviews::istream
   Range adaptors
   views::all_tviews::all
   ref_view
   owning_view
   as_rvalue_viewviews::as_rvalue
   (C++23)(C++23)
   filter_viewviews::filter
   transform_viewviews::transform
   take_viewviews::take
   take_while_viewviews::take_while
   concat_viewviews::concat
   (C++26)(C++26)
   drop_viewviews::drop
   drop_while_viewviews::drop_while
   join_viewviews::join
   join_with_viewviews::join_with
   (C++23)(C++23)
   lazy_split_viewviews::lazy_split
   split_viewviews::split
   views::counted
   common_viewviews::common
   reverse_viewviews::reverse
   as_const_viewviews::as_const
   (C++23)(C++23)
   elements_viewviews::elements
   keys_viewviews::keys
   values_viewviews::values
   enumerate_viewviews::enumerate
   (C++23)(C++23)
   zip_viewviews::zip
   (C++23)(C++23)
   zip_transform_viewviews::zip_transform
   (C++23)(C++23)
   adjacent_viewviews::adjacent
   (C++23)(C++23)
   views::pairwise
   (C++23)
   adjacent_transform_viewviews::adjacent_transform
   (C++23)(C++23)
   views::pairwise_transform
   (C++23)
   chunk_viewviews::chunk
   (C++23)(C++23)
   slide_viewviews::slide
   (C++23)(C++23)
   chunk_by_viewviews::chunk_by
   (C++23)(C++23)
   stride_viewviews::stride
   (C++23)(C++23)
   cartesian_product_viewviews::cartesian_product
   (C++23)(C++23)
   Range generators
   std::generator
   (C++23)
   Range adaptor objects
   Range adaptor closure objects
   range_adaptor_closure
   (C++23)
   Helper items
   copyable-box
   movable-box
   (until C++23)(C++23)
   simple-view
   non-propagating-cache

   Defined in header <ranges>
   template<class T>
   concept view = ranges::range<T> && std::movable<T> &&
   ranges::enable_view<T>;
   (1)                       (since C++20)
   template<class T>

   inline constexpr bool enable_view =
       std::derived_from<T, view_base> ||
   /*is-derived-from-view-interface*/<T>;
   (2)                       (since C++20)
   struct view_base { };
   (3)                       (since C++20)
   1) The view concept specifies the requirements of a range type that has
   suitable semantic properties for use in constructing range adaptor
   pipelines.
   2) The enable_view variable template is used to indicate whether a
   range is a view. /*is-derived-from-view-interface*/<T> is true if and
   only if T has exactly one public base class ranges::view_interface<U>
   for some type U, and T has no base classes of type
   ranges::view_interface<V> for any other type V.
   Users may specialize enable_view to true for cv-unqualified
   program-defined types which model view, and false for types which do
   not. Such specializations must be usable in constant expressions and
   have type const bool.
   3) Deriving from view_base enables range types to model view.

Semantic requirements

   1) T models view only if:
     * move construction of T has constant time complexity, and
     * if \(\scriptsize N\)N copies and/or moves are made from a T object
       holding \(\scriptsize M\)M elements, then these \(\scriptsize N\)N
       objects have \(\scriptsize \mathcal{O}{(N+M)}\)(N+M) destruction
       (which implies that a moved-from view object has \(\scriptsize
       \mathcal{O}{(1)}\)(1) destruction), and
     * either std::copy_constructible<T> is false, or copy construction of
       T has constant time complexity, and
     * either std::copyable<T> is false, or copy assignment of T has no
       more time complexity than destruction followed by copy
       construction.

Notes

   Examples of view types are:
     * A range type that wraps a pair of iterators, e.g.,
       std::ranges::subrange<I>.
     * A range type that holds its elements by std::shared_ptr and shares
       ownership with all its copies.
     * A range type that generates its elements on demand, e.g.,
       std::ranges::iota_view.

   A copyable container such as std::vector<std::string> generally does
   not meet the semantic requirements of view since copying the container
   copies all of the elements, which cannot be done in constant time.

   While views were originally described as cheaply copyable and
   non-owning ranges, a type is not required to be copyable or non-owning
   for it to model view. However, it must still be cheap to copy (if it is
   copyable), move, assign, and destroy, so that range adaptors will not
   have unexpected complexity.

   By default, a type modeling movable and range is considered a view if
   it is publicly and unambiguously derived from view_base, or exactly one
   specialization of std::ranges::view_interface.

Example

   A minimum view.
#include <ranges>

struct ArchetypalView : std::ranges::view_interface<ArchetypalView>
{
    int* begin();
    int* end();
};

static_assert(std::ranges::view<ArchetypalView>);

Defect reports

   The following behavior-changing defect reports were applied
   retroactively to previously published C++ standards.
   DR Applied to Behavior as published Correct behavior
   P2325R3 C++20 view required default_initializable does not require
   LWG 3549 C++20 enable_view did not detect inheritance from
   view_interface detects
   P2415R2 C++20 the restriction on the time complexity of destruction was
   too strict relaxed
   Retrieved from
   "https://en.cppreference.com/mwiki/index.php?title=cpp/ranges/view&oldi
   d=171719"

Navigation

     * Online version
     * Offline version retrieved 2024-06-10 08:17.

     * This page was last modified on 13 May 2024, at 14:30.
     * This page has been accessed 150,845 times.
