std::packaged_task<R(Args...)>::packaged_task

   From cppreference.com
   < cpp | thread | packaged task

   C++
   Compiler support
   Freestanding and hosted
   Language
   Standard library
   Standard library headers
   Named requirements
   Feature test macros (C++20)
   Language support library
   Concepts library (C++20)
   Metaprogramming library (C++11)
   Diagnostics library
   General utilities library
   Strings library
   Containers library
   Iterators library
   Ranges library (C++20)
   Algorithms library
   Numerics library
   Localizations library
   Input/output library
   Filesystem library (C++17)
   Regular expressions library (C++11)
   Concurrency support library (C++11)
   Technical specifications
   Symbols index
   External libraries

   Concurrency support library
   Threads
   thread
   (C++11)
   jthread
   (C++20)
   stop_token
   (C++20)
   stop_source
   (C++20)
   stop_callback
   (C++20)
   hardware_destructive_interference_sizehardware_constructive_interferenc
   e_size
   (C++17)(C++17)
   this_thread namespace
   get_id
   (C++11)
   yield
   (C++11)
   sleep_for
   (C++11)
   sleep_until
   (C++11)
   Mutual exclusion
   mutex
   (C++11)
   recursive_mutex
   (C++11)
   shared_mutex
   (C++17)
   timed_mutex
   (C++11)
   recursive_timed_mutex
   (C++11)
   shared_timed_mutex
   (C++14)
   Generic lock management
   lock_guard
   (C++11)
   scoped_lock
   (C++17)
   unique_lock
   (C++11)
   shared_lock
   (C++14)
   defer_lock_ttry_to_lock_tadopt_lock_t
   (C++11)(C++11)(C++11)
   lock
   (C++11)
   try_lock
   (C++11)
   defer_locktry_to_lockadopt_lock
   (C++11)(C++11)(C++11)
   once_flag
   (C++11)
   call_once
   (C++11)
   Condition variables
   condition_variable
   (C++11)
   condition_variable_any
   (C++11)
   notify_all_at_thread_exit
   (C++11)
   cv_status
   (C++11)
   Semaphores
   counting_semaphorebinary_semaphore
   (C++20)(C++20)
   Latches and Barriers
   latch
   (C++20)
   barrier
   (C++20)
   Futures
   promise
   (C++11)
   future
   (C++11)
   shared_future
   (C++11)
   packaged_task
   (C++11)
   async
   (C++11)
   launch
   (C++11)
   future_status
   (C++11)
   future_error
   (C++11)
   future_category
   (C++11)
   future_errc
   (C++11)
   Safe Reclamation
   rcu_obj_base
   (C++26)
   rcu_domain
   (C++26)
   rcu_default_domain
   (C++26)
   rcu_synchronize
   (C++26)
   rcu_barrier
   (C++26)
   rcu_retire
   (C++26)
   Hazard Pointers
   hazard_pointer_obj_base
   (C++26)
   hazard_pointer
   (C++26)
   make_hazard_pointer
   (C++26)
   Atomic types
   atomic
   (C++11)
   atomic_ref
   (C++20)
   atomic_flag
   (C++11)
   Initialization of atomic types
   atomic_init
   (C++11)(deprecated in C++20)
   ATOMIC_VAR_INIT
   (C++11)(deprecated in C++20)
   ATOMIC_FLAG_INIT
   (C++11)
   Memory ordering
   memory_order
   (C++11)
   kill_dependency
   (C++11)
   atomic_thread_fence
   (C++11)
   atomic_signal_fence
   (C++11)
   Free functions for atomic operations
   atomic_storeatomic_store_explicit
   (C++11)(C++11)
   atomic_loadatomic_load_explicit
   (C++11)(C++11)
   atomic_exchangeatomic_exchange_explicit
   (C++11)(C++11)
   atomic_compare_exchange_weakatomic_compare_exchange_weak_explicitatomic
   _compare_exchange_strongatomic_compare_exchange_strong_explicit
   (C++11)(C++11)(C++11)(C++11)
   atomic_fetch_addatomic_fetch_add_explicit
   (C++11)(C++11)
   atomic_fetch_subatomic_fetch_sub_explicit
   (C++11)(C++11)
   atomic_fetch_andatomic_fetch_and_explicit
   (C++11)(C++11)
   atomic_fetch_oratomic_fetch_or_explicit
   (C++11)(C++11)
   atomic_fetch_xoratomic_fetch_xor_explicit
   (C++11)(C++11)
   atomic_fetch_maxatomic_fetch_max_explicit
   (C++26)(C++26)
   atomic_fetch_minatomic_fetch_min_explicit
   (C++26)(C++26)
   atomic_is_lock_free
   (C++11)
   atomic_waitatomic_wait_explicit
   (C++20)(C++20)
   atomic_notify_one
   (C++20)
   atomic_notify_all
   (C++20)
   Free functions for atomic flags
   atomic_flag_test_and_setatomic_flag_test_and_set_explicit
   (C++11)(C++11)
   atomic_flag_clearatomic_flag_clear_explicit
   (C++11)(C++11)
   atomic_flag_testatomic_flag_test_explicit
   (C++20)(C++20)
   atomic_flag_waitatomic_flag_wait_explicit
   (C++20)(C++20)
   atomic_flag_notify_one
   (C++20)
   atomic_flag_notify_all
   (C++20)

   std::packaged_task
   Member functions
   packaged_task::packaged_task
   packaged_task::~packaged_task
   packaged_task::operator=
   packaged_task::valid
   packaged_task::swap
   Getting the result
   packaged_task::get_future
   Execution
   packaged_task::operator()
   packaged_task::make_ready_at_thread_exit
   packaged_task::reset
   Non-member functions
   swap(std::packaged_task)
   Helper classes
   uses_allocator<std::packaged_task>
   (until C++17)
   Deduction guides(C++17)

   packaged_task() noexcept;
   (1) (since C++11)
   template< class F >
   explicit packaged_task( F&& f );
   (2) (since C++11)
   template< class F, class Allocator >
   explicit packaged_task( std::allocator_arg_t, const Allocator& a, F&& f
   );
   (3) (since C++11)
   (until C++17)
   packaged_task( const packaged_task& ) = delete;
   (4) (since C++11)
   packaged_task( packaged_task&& rhs ) noexcept;
   (5) (since C++11)

   Constructs a new std::packaged_task object.
   1) Constructs a std::packaged_task object with no task and no shared
   state.
   2,3) Constructs a std::packaged_task object with a shared state and a
   copy of the task, initialized with std::forward<F>(f). The allocator a
   is used to allocate memory necessary to store the task.(until C++17)
   These overloads participate in overload resolution only if
   std::decay<F>::type is not the same type as
   std::packaged_task<R(Args...)>.

   Let t1, t2, ..., tN be values of the corresponding types in Args, if
   INVOKE<R>(f, t1, t2, ..., tN) is not a valid expression, the program is
   ill-formed.
   (until C++17)

   If std::is_invocable_r_v<R, F, Args...> is false, the program is
   ill-formed.
   (since C++17)
   If invoking f itself and invoking a copy of f behave differently, the
   behavior is undefined.
   4) The copy constructor is deleted, std::packaged_task is move-only.
   5) Constructs a std::packaged_task with the shared state and task
   formerly owned by rhs, leaving rhs with no shared state and a
   moved-from task.

Parameters

   f - the callable target (function, member function, lambda expression,
   function object) to execute
   a - the allocator to use when storing the task
   rhs - the std::packaged_task to move from

Exceptions

   2) Any exceptions thrown by copy/move constructor of f and possibly
   std::bad_alloc if the allocation fails.
   3) Any exceptions thrown by copy/move constructor of f and by the
   allocator's allocate function if memory allocation fails.

Example

   Run this code
#include <future>
#include <iostream>
#include <thread>

int fib(int n)
{
    if (n < 3)
        return 1;
    else
        return fib(n - 1) + fib(n - 2);
}

int main()
{
    std::packaged_task<int(int)> fib_task(&fib);

    std::cout << "Starting task\n";
    auto result = fib_task.get_future();
    std::thread t(std::move(fib_task), 42);

    std::cout << "Waiting for task to finish..." << std::endl;
    std::cout << result.get() << '\n';

    std::cout << "Task complete\n";
    t.join();
}

   Output:
Starting task
Waiting for task to finish...
267914296
Task complete

Defect reports

   The following behavior-changing defect reports were applied
   retroactively to previously published C++ standards.
   DR Applied to Behavior as published Correct behavior
   LWG 2067 C++11 the parameter type of the copy constructor was
   packaged_task& added const
   LWG 2097 C++11 for overloads (2,3), F could be
   std::packaged_task<R(Args...)> F is constrained
   Retrieved from
   "https://en.cppreference.com/mwiki/index.php?title=cpp/thread/packaged_
   task/packaged_task&oldid=169922"

Navigation

     * Online version
     * Offline version retrieved 2024-06-10 08:17.

     * This page was last modified on 23 February 2024, at 00:23.
     * This page has been accessed 52,350 times.
