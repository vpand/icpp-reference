std::atomic_ref<T>::compare_exchange_weak,
std::atomic_ref<T>::compare_exchange_strong

   From cppreference.com
   < cpp | atomic | atomic ref

   C++
   Compiler support
   Freestanding and hosted
   Language
   Standard library
   Standard library headers
   Named requirements
   Feature test macros (C++20)
   Language support library
   Concepts library (C++20)
   Metaprogramming library (C++11)
   Diagnostics library
   General utilities library
   Strings library
   Containers library
   Iterators library
   Ranges library (C++20)
   Algorithms library
   Numerics library
   Localizations library
   Input/output library
   Filesystem library (C++17)
   Regular expressions library (C++11)
   Concurrency support library (C++11)
   Technical specifications
   Symbols index
   External libraries

   Concurrency support library
   Threads
   thread
   (C++11)
   jthread
   (C++20)
   stop_token
   (C++20)
   stop_source
   (C++20)
   stop_callback
   (C++20)
   hardware_destructive_interference_sizehardware_constructive_interferenc
   e_size
   (C++17)(C++17)
   this_thread namespace
   get_id
   (C++11)
   yield
   (C++11)
   sleep_for
   (C++11)
   sleep_until
   (C++11)
   Mutual exclusion
   mutex
   (C++11)
   recursive_mutex
   (C++11)
   shared_mutex
   (C++17)
   timed_mutex
   (C++11)
   recursive_timed_mutex
   (C++11)
   shared_timed_mutex
   (C++14)
   Generic lock management
   lock_guard
   (C++11)
   scoped_lock
   (C++17)
   unique_lock
   (C++11)
   shared_lock
   (C++14)
   defer_lock_ttry_to_lock_tadopt_lock_t
   (C++11)(C++11)(C++11)
   lock
   (C++11)
   try_lock
   (C++11)
   defer_locktry_to_lockadopt_lock
   (C++11)(C++11)(C++11)
   once_flag
   (C++11)
   call_once
   (C++11)
   Condition variables
   condition_variable
   (C++11)
   condition_variable_any
   (C++11)
   notify_all_at_thread_exit
   (C++11)
   cv_status
   (C++11)
   Semaphores
   counting_semaphorebinary_semaphore
   (C++20)(C++20)
   Latches and Barriers
   latch
   (C++20)
   barrier
   (C++20)
   Futures
   promise
   (C++11)
   future
   (C++11)
   shared_future
   (C++11)
   packaged_task
   (C++11)
   async
   (C++11)
   launch
   (C++11)
   future_status
   (C++11)
   future_error
   (C++11)
   future_category
   (C++11)
   future_errc
   (C++11)
   Safe Reclamation
   rcu_obj_base
   (C++26)
   rcu_domain
   (C++26)
   rcu_default_domain
   (C++26)
   rcu_synchronize
   (C++26)
   rcu_barrier
   (C++26)
   rcu_retire
   (C++26)
   Hazard Pointers
   hazard_pointer_obj_base
   (C++26)
   hazard_pointer
   (C++26)
   make_hazard_pointer
   (C++26)
   Atomic types
   atomic
   (C++11)
   atomic_ref
   (C++20)
   atomic_flag
   (C++11)
   Initialization of atomic types
   atomic_init
   (C++11)(deprecated in C++20)
   ATOMIC_VAR_INIT
   (C++11)(deprecated in C++20)
   ATOMIC_FLAG_INIT
   (C++11)
   Memory ordering
   memory_order
   (C++11)
   kill_dependency
   (C++11)
   atomic_thread_fence
   (C++11)
   atomic_signal_fence
   (C++11)
   Free functions for atomic operations
   atomic_storeatomic_store_explicit
   (C++11)(C++11)
   atomic_loadatomic_load_explicit
   (C++11)(C++11)
   atomic_exchangeatomic_exchange_explicit
   (C++11)(C++11)
   atomic_compare_exchange_weakatomic_compare_exchange_weak_explicitatomic
   _compare_exchange_strongatomic_compare_exchange_strong_explicit
   (C++11)(C++11)(C++11)(C++11)
   atomic_fetch_addatomic_fetch_add_explicit
   (C++11)(C++11)
   atomic_fetch_subatomic_fetch_sub_explicit
   (C++11)(C++11)
   atomic_fetch_andatomic_fetch_and_explicit
   (C++11)(C++11)
   atomic_fetch_oratomic_fetch_or_explicit
   (C++11)(C++11)
   atomic_fetch_xoratomic_fetch_xor_explicit
   (C++11)(C++11)
   atomic_fetch_maxatomic_fetch_max_explicit
   (C++26)(C++26)
   atomic_fetch_minatomic_fetch_min_explicit
   (C++26)(C++26)
   atomic_is_lock_free
   (C++11)
   atomic_waitatomic_wait_explicit
   (C++20)(C++20)
   atomic_notify_one
   (C++20)
   atomic_notify_all
   (C++20)
   Free functions for atomic flags
   atomic_flag_test_and_setatomic_flag_test_and_set_explicit
   (C++11)(C++11)
   atomic_flag_clearatomic_flag_clear_explicit
   (C++11)(C++11)
   atomic_flag_testatomic_flag_test_explicit
   (C++20)(C++20)
   atomic_flag_waitatomic_flag_wait_explicit
   (C++20)(C++20)
   atomic_flag_notify_one
   (C++20)
   atomic_flag_notify_all
   (C++20)

   std::atomic_ref
   Member functions
   atomic_ref::atomic_ref
   atomic_ref::operator=
   atomic_ref::is_lock_free
   atomic_ref::store
   atomic_ref::load
   atomic_ref::operator T
   atomic_ref::exchange
   atomic_ref::compare_exchange_strongatomic_ref::compare_exchange_weak
   atomic_ref::wait
   atomic_ref::notify_one
   atomic_ref::notify_all
   Constants
   atomic_ref::is_always_lock_free
   atomic_ref::required_alignment
   Specialized member functions
   Specialized for integral,
   floating-point and pointer types
   atomic_ref::fetch_add
   atomic_ref::fetch_sub
   atomic_ref::operator+=atomic_ref::operator-=
   Specialized for integral and
   pointer types only
   atomic_ref::fetch_max
   (C++26)
   atomic_ref::fetch_min
   (C++26)
   atomic_ref::operator++atomic_ref::operator++(int)atomic_ref::operator--
   atomic_ref::operator--(int)
   Specialized for integral types only
   atomic_ref::fetch_and
   atomic_ref::fetch_or
   atomic_ref::fetch_xor
   atomic_ref::operator&=atomic_ref::operator|=atomic_ref::operator^=

   bool compare_exchange_weak( T& expected, T desired,

                               std::memory_order success,
                               std::memory_order failure ) const noexcept;
   (1)                                                  (since C++20)
   bool compare_exchange_weak( T& expected, T desired,

                               std::memory_order order =
                                   std::memory_order_seq_cst ) const
   noexcept;
   (2)                                                  (since C++20)
   bool compare_exchange_strong( T& expected, T desired,

                                 std::memory_order success,
                                 std::memory_order failure ) const
   noexcept;
   (3)                                                  (since C++20)
   bool compare_exchange_strong( T& expected, T desired,

                                 std::memory_order order =
                                     std::memory_order_seq_cst ) const
   noexcept;
   (4)                                                  (since C++20)

   Atomically compares the value representation of the referenced object
   with that of expected, and if those are bitwise-equal, replaces the
   former with desired (performs a read-modify-write operation).
   Otherwise, loads the actual value stored in the referenced object into
   expected (performs a load operation).

   The memory models for the read-modify-write and load operations are
   success and failure respectively. In the (2) and (4) versions order is
   used for both read-modify-write and load operations, except that
   std::memory_order_acquire and std::memory_order_relaxed are used for
   the load operation if order == std::memory_order_acq_rel, or order ==
   std::memory_order_release respectively.

Parameters

   expected - reference to the value expected to be found in the object
   referenced by the atomic_ref object
   desired - the value to store in the referenced object if it is as
   expected
   success - the memory synchronization ordering for the read-modify-write
   operation if the comparison succeeds. All values are permitted
   failure - the memory synchronization ordering for the load operation if
   the comparison fails. Cannot be std::memory_order_release or
   std::memory_order_acq_rel
   order - the memory synchronization ordering for both operations

Return value

   true if the referenced object was successfully changed, false
   otherwise.

Notes

   The comparison and copying are bitwise (similar to std::memcmp and
   std::memcpy); no constructor, assignment operator, or comparison
   operator are used.

   The weak forms (1,2) of the functions are allowed to fail spuriously,
   that is, act as if *this != expected even if they are equal. When a
   compare-and-exchange is in a loop, the weak version will yield better
   performance on some platforms.

   When a weak compare-and-exchange would require a loop and a strong one
   would not, the strong one is preferable unless the object
   representation of T may include trap bits, or offers multiple object
   representations for the same value (e.g. floating-point NaN). In those
   cases, weak compare-and-exchange typically works because it quickly
   converges on some stable object representation.

   For a union with bits that participate in the value representations of
   some members but not the others, compare-and-exchange might always fail
   because such padding bits have indeterminate values when they do not
   participate in the value representation of the active member.

   Padding bits that never participate in an object's value representation
   are ignored.

Example

   This section is incomplete
   Reason: no example
   Retrieved from
   "https://en.cppreference.com/mwiki/index.php?title=cpp/atomic/atomic_re
   f/compare_exchange&oldid=161439"

Navigation

     * Online version
     * Offline version retrieved 2024-06-10 08:17.

     * This page was last modified on 26 October 2023, at 14:07.
     * This page has been accessed 17,206 times.
