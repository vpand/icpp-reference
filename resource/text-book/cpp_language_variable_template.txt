Variable template (since C++14)

   From cppreference.com
   < cpp | language

   C++
   Compiler support
   Freestanding and hosted
   Language
   Standard library
   Standard library headers
   Named requirements
   Feature test macros (C++20)
   Language support library
   Concepts library (C++20)
   Metaprogramming library (C++11)
   Diagnostics library
   General utilities library
   Strings library
   Containers library
   Iterators library
   Ranges library (C++20)
   Algorithms library
   Numerics library
   Localizations library
   Input/output library
   Filesystem library (C++17)
   Regular expressions library (C++11)
   Concurrency support library (C++11)
   Technical specifications
   Symbols index
   External libraries

   C++ language
   General topics
   Preprocessor
   Comments
   Keywords
   Escape sequences
   Flow control
   Conditional execution statements
   if
   switch
   Iteration statements (loops)
   for
   range-for (C++11)
   while
   do-while
   Jump statements
   continue - break
   goto - return
   Functions
   Function declaration
   Lambda function expression
   inline specifier
   Dynamic exception specifications (until C++17*)
   noexcept specifier (C++11)
   Exceptions
   throw-expression
   try block
   handler
   Namespaces
   Namespace declaration
   Namespace aliases
   Types
   Fundamental types
   Enumeration types
   Function types
   Class/struct types
   Union types
   Specifiers
   const/volatile
   decltype (C++11)
   auto (C++11)
   constexpr (C++11)
   consteval (C++20)
   constinit (C++20)
   Storage duration specifiers
   Initialization
   Default-initialization
   Value-initialization
   Zero-initialization
   Copy-initialization
   Direct-initialization
   Aggregate initialization
   List-initialization (C++11)
   Constant initialization
   Reference initialization
   Expressions
   Value categories
   Order of evaluation
   Operators
   Operator precedence
   Alternative representations
   Literals
   Boolean - Integer - Floating-point
   Character - String - nullptr (C++11)
   User-defined (C++11)
   Utilities
   Attributes (C++11)
   Types
   typedef declaration
   Type alias declaration (C++11)
   Casts
   Implicit conversions
   static_cast
   const_cast
   Explicit conversions
   dynamic_cast
   reinterpret_cast
   Memory allocation
   new expression
   delete expression
   Classes
   Class declaration
   Constructors
   this pointer
   Access specifiers
   friend specifier
   Class-specific function properties
   Virtual function
   override specifier (C++11)
   final specifier (C++11)
   explicit (C++11)
   static
   Special member functions
   Default constructor
   Copy constructor
   Move constructor (C++11)
   Copy assignment
   Move assignment (C++11)
   Destructor
   Templates
   Class template
   Function template
   Template specialization
   Parameter packs (C++11)
   Miscellaneous
   Inline assembly
   History of C++

   Declarations
   Overview
   Declaration syntax
   decl-specifier-seq
   Declarator
   Conflicting declarations
   Specifiers
   typedef
   inline
   virtual function specifier
   explicit function specifier
   friend
   constexpr
   (C++11)
   consteval
   (C++20)
   constinit
   (C++20)
   Storage class specifiers
   Translation-unit-local (C++20)
   class/struct
   union
   enum
   decltype
   (C++11)
   auto
   (C++11)
   alignas
   (C++11)
   constvolatile
   Pack indexing specifier (C++26)
   Elaborated type specifier
   Attributes (C++11)
   Declarators
   Reference
   Pointer
   Array
   Block declarations
   Simple-declaration
   ->Structured binding declaration (C++17)
   Alias declaration (C++11)
   Namespace alias definition
   using declaration
   using directive
   static_assert declaration (C++11)
   asm declaration
   Opaque enum declaration (C++11)
   Other declarations
   Namespace definition
   Function declaration
   Class template declaration
   Function template declaration
   Explicit template instantiation (C++11)
   Explicit template specialization
   Linkage specification
   Attribute declaration (C++11)
   Empty declaration

   Expressions
   General
   Value categories
   Order of evaluation
   Constant expressions
   Primary expressions
   Lambda expressions (C++11)
   Pack indexing expression (C++26)
   Potentially-evaluated expressions
   Literals
   Integer literals
   Floating-point literals
   Boolean literals
   Character literals
   Escape sequences
   String literals
   Null pointer literal (C++11)
   User-defined literal (C++11)
   Operators
   Assignment operators
   Increment and decrement
   Arithmetic operators
   Logical operators
   Comparison operators
   Member access operators
   Other operators
   new-expression
   delete-expression
   throw-expression
   alignof
   sizeof
   sizeof... (C++11)
   typeid
   noexcept (C++11)
   Fold expressions (C++17)
   Alternative representations of operators
   Precedence and associativity
   Operator overloading
   Default comparisons (C++20)
   Conversions
   Implicit conversions
   Explicit conversions
   Usual arithmetic conversions
   User-defined conversion
   const_cast
   static_cast
   dynamic_cast
   reinterpret_cast

   Templates
   Parameters and arguments
   Class templates
   Function templates
   Class member templates
   Variable templates (C++14)
   Template argument deduction
   Class template argument deduction (C++17)
   Explicit (full) specialization
   Partial specialization
   Dependent names
   Parameter packs (C++11)
      sizeof... (C++11)
      Fold expressions (C++17)
      Pack indexing (C++26)
   SFINAE
   Constraints and concepts (C++20)
   Requires expression (C++20)

   A variable template defines a family of variables or static data
   members.

Syntax

   template < parameter-list > variable-declaration
   variable-declaration - a declaration of a variable. The declared
   variable name becomes a template name.
   parameter-list - a non-empty comma-separated list of the template
   parameters, each of which is either non-type parameter, a type
   parameter, a template parameter, or a parameter pack of any of those.

Explanation

   A variable instantiated from a variable template is called an
   instantiated variable. A static data member instantiated from a static
   data member template is called an instantiated static data member.

   A variable template may be introduced by a template declaration at
   namespace scope, where variable-declaration declares a variable.
template<class T>
constexpr T pi = T(3.1415926535897932385L); // variable template

template<class T>
T circular_area(T r) // function template
{
    return pi<T> * r * r; // pi<T> is a variable template instantiation
}

   When used at class scope, variable template declares a static data
   member template.
using namespace std::literals;
struct matrix_constants
{
    template<class T>
    using pauli = hermitian_matrix<T, 2>; // alias template

    template<class T> // static data member template
    static constexpr pauli<T> sigmaX = {{0, 1}, {1, 0}};

    template<class T>
    static constexpr pauli<T> sigmaY = {{0, -1i}, {1i, 0}};

    template<class T>
    static constexpr pauli<T> sigmaZ = {{1, 0}, {0, -1}};
};

   As with other static members, a definition of a static data member
   template may be required. Such definition is provided outside the class
   definition. A template declaration of a static data member at namespace
   scope may also be a definition of a non-template data member of a class
   template:
struct limits
{
    template<typename T>
    static const T min; // declaration of a static data member template
};

template<typename T>
const T limits::min = { }; // definition of a static data member template

template<class T>
class X
{
    static T s; // declaration of a non-template static data member of a class t
emplate
};

template<class T>
T X<T>::s = 0; // definition of a non-template data member of a class template

   Unless a variable template was explicitly specialized or explicitly
   instantiated, it is implicitly instantiated when a specialization of
   the variable template is referenced in a context that requires a
   variable definition to exist or if the existence of the definition
   affects the semantics of the program, i.e. if the variable is needed
   for constant evaluation by an expression (the definition may be not
   used).

   The existence of a definition of a variable is considered to affect the
   semantics of the program if the variable is needed for constant
   evaluation by an expression, even if constant evaluation of the
   expression is not required or if constant expression evaluation does
   not use the definition.

Notes

   Until variable templates were introduced in C++14, parametrized
   variables were typically implemented as either static data members of
   class templates or as constexpr function templates returning the
   desired values.

   Variable templates cannot be used as template template arguments.
      Feature-test macro     Value    Std        Feature
   __cpp_variable_templates 201304L (C++14) Variable templates

Defect reports

   The following behavior-changing defect reports were applied
   retroactively to previously published C++ standards.
   DR Applied to Behavior as published Correct behavior
   CWG 2255 C++14 it was unclear whether a specialization of a static
   data member template is a static data member it is
   Retrieved from
   "https://en.cppreference.com/mwiki/index.php?title=cpp/language/variabl
   e_template&oldid=167758"

Navigation

     * Online version
     * Offline version retrieved 2024-06-10 08:17.

     * This page was last modified on 29 December 2023, at 21:59.
     * This page has been accessed 392,863 times.
