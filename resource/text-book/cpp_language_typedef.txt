typedef specifier

   From cppreference.com
   < cpp | language

   C++
   Compiler support
   Freestanding and hosted
   Language
   Standard library
   Standard library headers
   Named requirements
   Feature test macros (C++20)
   Language support library
   Concepts library (C++20)
   Metaprogramming library (C++11)
   Diagnostics library
   General utilities library
   Strings library
   Containers library
   Iterators library
   Ranges library (C++20)
   Algorithms library
   Numerics library
   Localizations library
   Input/output library
   Filesystem library (C++17)
   Regular expressions library (C++11)
   Concurrency support library (C++11)
   Technical specifications
   Symbols index
   External libraries

   C++ language
   General topics
   Preprocessor
   Comments
   Keywords
   Escape sequences
   Flow control
   Conditional execution statements
   if
   switch
   Iteration statements (loops)
   for
   range-for (C++11)
   while
   do-while
   Jump statements
   continue - break
   goto - return
   Functions
   Function declaration
   Lambda function expression
   inline specifier
   Dynamic exception specifications (until C++17*)
   noexcept specifier (C++11)
   Exceptions
   throw-expression
   try block
   handler
   Namespaces
   Namespace declaration
   Namespace aliases
   Types
   Fundamental types
   Enumeration types
   Function types
   Class/struct types
   Union types
   Specifiers
   const/volatile
   decltype (C++11)
   auto (C++11)
   constexpr (C++11)
   consteval (C++20)
   constinit (C++20)
   Storage duration specifiers
   Initialization
   Default-initialization
   Value-initialization
   Zero-initialization
   Copy-initialization
   Direct-initialization
   Aggregate initialization
   List-initialization (C++11)
   Constant initialization
   Reference initialization
   Expressions
   Value categories
   Order of evaluation
   Operators
   Operator precedence
   Alternative representations
   Literals
   Boolean - Integer - Floating-point
   Character - String - nullptr (C++11)
   User-defined (C++11)
   Utilities
   Attributes (C++11)
   Types
   typedef declaration
   Type alias declaration (C++11)
   Casts
   Implicit conversions
   static_cast
   const_cast
   Explicit conversions
   dynamic_cast
   reinterpret_cast
   Memory allocation
   new expression
   delete expression
   Classes
   Class declaration
   Constructors
   this pointer
   Access specifiers
   friend specifier
   Class-specific function properties
   Virtual function
   override specifier (C++11)
   final specifier (C++11)
   explicit (C++11)
   static
   Special member functions
   Default constructor
   Copy constructor
   Move constructor (C++11)
   Copy assignment
   Move assignment (C++11)
   Destructor
   Templates
   Class template
   Function template
   Template specialization
   Parameter packs (C++11)
   Miscellaneous
   Inline assembly
   History of C++

   Declarations
   Overview
   Declaration syntax
   decl-specifier-seq
   Declarator
   Conflicting declarations
   Specifiers
   typedef
   inline
   virtual function specifier
   explicit function specifier
   friend
   constexpr
   (C++11)
   consteval
   (C++20)
   constinit
   (C++20)
   Storage class specifiers
   Translation-unit-local (C++20)
   class/struct
   union
   enum
   decltype
   (C++11)
   auto
   (C++11)
   alignas
   (C++11)
   constvolatile
   Pack indexing specifier (C++26)
   Elaborated type specifier
   Attributes (C++11)
   Declarators
   Reference
   Pointer
   Array
   Block declarations
   Simple-declaration
   ->Structured binding declaration (C++17)
   Alias declaration (C++11)
   Namespace alias definition
   using declaration
   using directive
   static_assert declaration (C++11)
   asm declaration
   Opaque enum declaration (C++11)
   Other declarations
   Namespace definition
   Function declaration
   Class template declaration
   Function template declaration
   Explicit template instantiation (C++11)
   Explicit template specialization
   Linkage specification
   Attribute declaration (C++11)
   Empty declaration

          + typedef - creates an alias that can be used anywhere in place
            of a (possibly complex) type name.

Explanation

   The typedef specifier, when used in a declaration, specifies that the
   declaration is a typedef declaration rather than a variable or function
   declaration.

   Typically, the typedef specifier appears at the start of the
   declaration, though it is permitted to appear after the type
   specifiers, or between two type specifiers. The typedef specifier
   cannot be combined with any other specifier except for type specifiers.

   A typedef declaration may declare one or many identifiers on the same
   line (e.g. int and a pointer to int), it may declare array and function
   types, pointers and references, class types, etc. Every identifier
   introduced in this declaration becomes a typedef name, which is a
   synonym for the type of the object or function that it would become if
   the keyword typedef were removed.

   The typedef names are aliases for existing types, and are not
   declarations of new types. typedef cannot be used to change the meaning
   of an existing type name (including a typedef name). Once declared, a
   typedef name may only be redeclared to refer to the same type again.
   Typedef names are only in effect in the scope where they are visible:
   different functions or class declarations may define identically-named
   types with different meaning.

   The typedef specifier may not appear in the declaration of a function
   parameter nor in the decl-specifier-seq of a function definition:
void f1(typedef int param); // ill-formed
typedef int f2() {}         // ill-formed

   The typedef specifier may not appear in a declaration that does not
   contain a declarator:
typedef struct X {}; // ill-formed

typedef name for linkage purposes

   If a typedef declaration defines an unnamed class or enumeration, the
   first typedef name of the class type or enumeration type declared by
   the declaration is the typedef name for linkage purposes of that type.

   For example, in typedef struct { /* ... */ } S;, S is a typedef name
   for linkage purposes. The class or enumeration type defined in this way
   has external linkage (unless it is in an unnamed namespace).

   An unnamed class defined in this way should only contain C-compatible
   constructs. In particular, it must not
     * declare any members other than non-static data members, member
       enumerations, or member classes,
     * have any base classes or default member initializers, or
     * contain a lambda expression,

   and all member classes must also satisfy these requirements
   (recursively).
   (since C++20)

Keywords

   typedef

Notes

   Type aliases provide the same functionality as typedef declarations
   using a different syntax, and are also applicable to template names.
   (since C++11)

Example

// simple typedef
typedef unsigned long ulong;

// the following two objects have the same type
unsigned long l1;
ulong l2;

// more complicated typedef
typedef int int_t, *intp_t, (&fp)(int, ulong), arr_t[10];

// the following two objects have the same type
int a1[10];
arr_t a2;

// beware: the following two objects do not have the same type
const intp_t p1 = 0; // int *const p1 = 0
const int *p2;

// common C idiom to avoid having to write "struct S"
typedef struct { int a; int b; } S, *pS;

// the following two objects have the same type
pS ps1;
S* ps2;

// error: storage-class-specifier cannot appear in a typedef declaration
// typedef static unsigned int uint;

// typedef can be used anywhere in the decl-specifier-seq
long unsigned typedef int long ullong;
// more conventionally spelled "typedef unsigned long long int ullong;"

// std::add_const, like many other metafunctions, use member typedefs
template<class T>
struct add_const
{
    typedef const T type;
};

typedef struct Node
{
    struct listNode* next; // declares a new (incomplete) struct type named list
Node
} listNode; // error: conflicts with the previously declared struct name

// C++20 error: "struct with typedef name for linkage" has member functions
typedef struct { void f() {} } C_Incompatible;

Defect reports

   The following behavior-changing defect reports were applied
   retroactively to previously published C++ standards.
   DR Applied to Behavior as published Correct behavior
   CWG 576 C++98 typedef was not allowed in the entire function definition
   allowed in function body
   CWG 2071 C++98 typedef could appear in a declaration that does not
   contain a declarator now disallowed

See also

     * Type alias
     * Alias template

   Retrieved from
   "https://en.cppreference.com/mwiki/index.php?title=cpp/language/typedef
   &oldid=169693"

Navigation

     * Online version
     * Offline version retrieved 2024-06-10 08:17.

     * This page was last modified on 9 February 2024, at 01:10.
     * This page has been accessed 1,513,555 times.
