std::condition_variable

   From cppreference.com
   < cpp | thread

   C++
   Compiler support
   Freestanding and hosted
   Language
   Standard library
   Standard library headers
   Named requirements
   Feature test macros (C++20)
   Language support library
   Concepts library (C++20)
   Metaprogramming library (C++11)
   Diagnostics library
   General utilities library
   Strings library
   Containers library
   Iterators library
   Ranges library (C++20)
   Algorithms library
   Numerics library
   Localizations library
   Input/output library
   Filesystem library (C++17)
   Regular expressions library (C++11)
   Concurrency support library (C++11)
   Technical specifications
   Symbols index
   External libraries

   Concurrency support library
   Threads
   thread
   (C++11)
   jthread
   (C++20)
   stop_token
   (C++20)
   stop_source
   (C++20)
   stop_callback
   (C++20)
   hardware_destructive_interference_sizehardware_constructive_interferenc
   e_size
   (C++17)(C++17)
   this_thread namespace
   get_id
   (C++11)
   yield
   (C++11)
   sleep_for
   (C++11)
   sleep_until
   (C++11)
   Mutual exclusion
   mutex
   (C++11)
   recursive_mutex
   (C++11)
   shared_mutex
   (C++17)
   timed_mutex
   (C++11)
   recursive_timed_mutex
   (C++11)
   shared_timed_mutex
   (C++14)
   Generic lock management
   lock_guard
   (C++11)
   scoped_lock
   (C++17)
   unique_lock
   (C++11)
   shared_lock
   (C++14)
   defer_lock_ttry_to_lock_tadopt_lock_t
   (C++11)(C++11)(C++11)
   lock
   (C++11)
   try_lock
   (C++11)
   defer_locktry_to_lockadopt_lock
   (C++11)(C++11)(C++11)
   once_flag
   (C++11)
   call_once
   (C++11)
   Condition variables
   condition_variable
   (C++11)
   condition_variable_any
   (C++11)
   notify_all_at_thread_exit
   (C++11)
   cv_status
   (C++11)
   Semaphores
   counting_semaphorebinary_semaphore
   (C++20)(C++20)
   Latches and Barriers
   latch
   (C++20)
   barrier
   (C++20)
   Futures
   promise
   (C++11)
   future
   (C++11)
   shared_future
   (C++11)
   packaged_task
   (C++11)
   async
   (C++11)
   launch
   (C++11)
   future_status
   (C++11)
   future_error
   (C++11)
   future_category
   (C++11)
   future_errc
   (C++11)
   Safe Reclamation
   rcu_obj_base
   (C++26)
   rcu_domain
   (C++26)
   rcu_default_domain
   (C++26)
   rcu_synchronize
   (C++26)
   rcu_barrier
   (C++26)
   rcu_retire
   (C++26)
   Hazard Pointers
   hazard_pointer_obj_base
   (C++26)
   hazard_pointer
   (C++26)
   make_hazard_pointer
   (C++26)
   Atomic types
   atomic
   (C++11)
   atomic_ref
   (C++20)
   atomic_flag
   (C++11)
   Initialization of atomic types
   atomic_init
   (C++11)(deprecated in C++20)
   ATOMIC_VAR_INIT
   (C++11)(deprecated in C++20)
   ATOMIC_FLAG_INIT
   (C++11)
   Memory ordering
   memory_order
   (C++11)
   kill_dependency
   (C++11)
   atomic_thread_fence
   (C++11)
   atomic_signal_fence
   (C++11)
   Free functions for atomic operations
   atomic_storeatomic_store_explicit
   (C++11)(C++11)
   atomic_loadatomic_load_explicit
   (C++11)(C++11)
   atomic_exchangeatomic_exchange_explicit
   (C++11)(C++11)
   atomic_compare_exchange_weakatomic_compare_exchange_weak_explicitatomic
   _compare_exchange_strongatomic_compare_exchange_strong_explicit
   (C++11)(C++11)(C++11)(C++11)
   atomic_fetch_addatomic_fetch_add_explicit
   (C++11)(C++11)
   atomic_fetch_subatomic_fetch_sub_explicit
   (C++11)(C++11)
   atomic_fetch_andatomic_fetch_and_explicit
   (C++11)(C++11)
   atomic_fetch_oratomic_fetch_or_explicit
   (C++11)(C++11)
   atomic_fetch_xoratomic_fetch_xor_explicit
   (C++11)(C++11)
   atomic_fetch_maxatomic_fetch_max_explicit
   (C++26)(C++26)
   atomic_fetch_minatomic_fetch_min_explicit
   (C++26)(C++26)
   atomic_is_lock_free
   (C++11)
   atomic_waitatomic_wait_explicit
   (C++20)(C++20)
   atomic_notify_one
   (C++20)
   atomic_notify_all
   (C++20)
   Free functions for atomic flags
   atomic_flag_test_and_setatomic_flag_test_and_set_explicit
   (C++11)(C++11)
   atomic_flag_clearatomic_flag_clear_explicit
   (C++11)(C++11)
   atomic_flag_testatomic_flag_test_explicit
   (C++20)(C++20)
   atomic_flag_waitatomic_flag_wait_explicit
   (C++20)(C++20)
   atomic_flag_notify_one
   (C++20)
   atomic_flag_notify_all
   (C++20)

   std::condition_variable
   Member functions
   condition_variable::condition_variable
   condition_variable::~condition_variable
   Notification
   condition_variable::notify_one
   condition_variable::notify_all
   Waiting
   condition_variable::wait
   condition_variable::wait_for
   condition_variable::wait_until
   Native handle
   condition_variable::native handle

   Defined in header <condition_variable>
   class condition_variable;
                                         (since C++11)

   std::condition_variable is a synchronization primitive used with a
   std::mutex to block one or more threads until another thread both
   modifies a shared variable (the condition) and notifies the
   std::condition_variable.

   The thread that intends to modify the shared variable must:
    1. Acquire a std::mutex (typically via std::lock_guard).
    2. Modify the shared variable while the lock is owned.
    3. Call notify_one or notify_all on the std::condition_variable (can
       be done after releasing the lock).

   Even if the shared variable is atomic, it must be modified while owning
   the mutex to correctly publish the modification to the waiting thread.

   Any thread that intends to wait on a std::condition_variable must:
    1. Acquire a std::unique_lock<std::mutex> on the mutex used to protect
       the shared variable.
    2. Do one of the following:

         1. Check the condition, in case it was already updated and
            notified.
         2. Call wait, wait_for, or wait_until on the
            std::condition_variable (atomically releases the mutex and
            suspends thread execution until the condition variable is
            notified, a timeout expires, or a spurious wakeup occurs, then
            atomically acquires the mutex before returning).
         3. Check the condition and resume waiting if not satisfied.

                or:

         1. Use the predicated overload of wait, wait_for, and wait_until,
            which performs the same three steps.

   std::condition_variable works only with std::unique_lock<std::mutex>,
   which allows for maximal efficiency on some platforms.
   std::condition_variable_any provides a condition variable that works
   with any BasicLockable object, such as std::shared_lock.

   Condition variables permit concurrent invocation of the wait, wait_for,
   wait_until, notify_one and notify_all member functions.

   The class std::condition_variable is a StandardLayoutType. It is not
   CopyConstructible, MoveConstructible, CopyAssignable, or
   MoveAssignable.

Nested types

   Name               Definition
   native_handle_type implementation-defined

Member functions

   (constructor)
   constructs the object
   (public member function)
   (destructor)
   destructs the object
   (public member function)
   operator=
   [deleted]
   not copy-assignable
   (public member function)

Notification

   notify_one
   notifies one waiting thread
   (public member function)
   notify_all
   notifies all waiting threads
   (public member function)

Waiting

   wait
   blocks the current thread until the condition variable is awakened
   (public member function)
   wait_for
   blocks the current thread until the condition variable is awakened or
   after the specified timeout duration
   (public member function)
   wait_until
   blocks the current thread until the condition variable is awakened or
   until specified time point has been reached
   (public member function)

Native handle

   native_handle
   returns the native handle
   (public member function)

Example

   std::condition_variable is used in combination with a std::mutex to
   facilitate inter-thread communication.
   Run this code
#include <condition_variable>
#include <iostream>
#include <mutex>
#include <string>
#include <thread>

std::mutex m;
std::condition_variable cv;
std::string data;
bool ready = false;
bool processed = false;

void worker_thread()
{
    // wait until main() sends data
    std::unique_lock lk(m);
    cv.wait(lk, []{ return ready; });

    // after the wait, we own the lock
    std::cout << "Worker thread is processing data\n";
    data += " after processing";

    // send data back to main()
    processed = true;
    std::cout << "Worker thread signals data processing completed\n";

    // manual unlocking is done before notifying, to avoid waking up
    // the waiting thread only to block again (see notify_one for details)
    lk.unlock();
    cv.notify_one();
}

int main()
{
    std::thread worker(worker_thread);

    data = "Example data";
    // send data to the worker thread
    {
        std::lock_guard lk(m);
        ready = true;
        std::cout << "main() signals data ready for processing\n";
    }
    cv.notify_one();

    // wait for the worker
    {
        std::unique_lock lk(m);
        cv.wait(lk, []{ return processed; });
    }
    std::cout << "Back in main(), data = " << data << '\n';

    worker.join();
}

   Output:
main() signals data ready for processing
Worker thread is processing data
Worker thread signals data processing completed
Back in main(), data = Example data after processing

See also

   condition_variable_any
   (C++11)
   provides a condition variable associated with any lock type
   (class)
   mutex
   (C++11)
   provides basic mutual exclusion facility
   (class)
   lock_guard
   (C++11)
   implements a strictly scope-based mutex ownership wrapper
   (class template)
   unique_lock
   (C++11)
   implements movable mutex ownership wrapper
   (class template)
   Retrieved from
   "https://en.cppreference.com/mwiki/index.php?title=cpp/thread/condition
   _variable&oldid=170070"

Navigation

     * Online version
     * Offline version retrieved 2024-06-10 08:17.

     * This page was last modified on 4 March 2024, at 23:17.
     * This page has been accessed 2,399,577 times.
