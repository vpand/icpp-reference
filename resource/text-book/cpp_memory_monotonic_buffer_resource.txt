std::pmr::monotonic_buffer_resource

   From cppreference.com
   < cpp | memory

   C++
   Compiler support
   Freestanding and hosted
   Language
   Standard library
   Standard library headers
   Named requirements
   Feature test macros (C++20)
   Language support library
   Concepts library (C++20)
   Metaprogramming library (C++11)
   Diagnostics library
   General utilities library
   Strings library
   Containers library
   Iterators library
   Ranges library (C++20)
   Algorithms library
   Numerics library
   Localizations library
   Input/output library
   Filesystem library (C++17)
   Regular expressions library (C++11)
   Concurrency support library (C++11)
   Technical specifications
   Symbols index
   External libraries

   Dynamic memory management
   Uninitialized memory algorithms
   uninitialized_copy
   uninitialized_fill
   uninitialized_move
   (C++17)
   uninitialized_default_construct
   (C++17)
   uninitialized_value_construct
   (C++17)
   destroy
   (C++17)
   destroy_at
   (C++17)
   voidify
   (C++20)
   uninitialized_copy_n
   (C++11)
   uninitialized_fill_n
   uninitialized_move_n
   (C++17)
   uninitialized_default_construct_n
   (C++17)
   uninitialized_value_construct_n
   (C++17)
   destroy_n
   (C++17)
   construct_at
   (C++20)
   Constrained uninitialized memory algorithms
   ranges::uninitialized_copy
   (C++20)
   ranges::uninitialized_fill
   (C++20)
   ranges::uninitialized_move
   (C++20)
   ranges::construct_at
   (C++20)
   ranges::destroy
   (C++20)
   ranges::destroy_n
   (C++20)
   ranges::destroy_at
   (C++20)
   ranges::uninitialized_copy_n
   (C++20)
   ranges::uninitialized_fill_n
   (C++20)
   ranges::uninitialized_move_n
   (C++20)
   ranges::uninitialized_default_construct
   (C++20)
   ranges::uninitialized_value_construct
   (C++20)
   ranges::uninitialized_default_construct_n
   (C++20)
   ranges::uninitialized_value_construct_n
   (C++20)
   Allocators
   allocator
   allocator_traits
   (C++11)
   allocation_result
   (C++23)
   allocator_arg
   (C++11)
   uses_allocator
   (C++11)
   uses_allocator_construction_args
   (C++20)
   make_obj_using_allocator
   (C++20)
   uninitialized_construct_using_allocator
   (C++20)
   scoped_allocator_adaptor
   (C++11)
   pmr::polymorphic_allocator
   (C++17)
   Memory resources
   pmr::memory_resource
   (C++17)
   pmr::get_default_resource
   (C++17)
   pmr::set_default_resource
   (C++17)
   pmr::new_delete_resource
   (C++17)
   pmr::null_memory_resource
   (C++17)
   pmr::synchronized_pool_resource
   (C++17)
   pmr::unsynchronized_pool_resource
   (C++17)
   pmr::monotonic_buffer_resource
   (C++17)
   pmr::pool_options
   (C++17)
   Garbage collection support
   declare_reachable
   (C++11)(until C++23)
   undeclare_reachable
   (C++11)(until C++23)
   declare_no_pointers
   (C++11)(until C++23)
   undeclare_no_pointers
   (C++11)(until C++23)
   pointer_safety
   (C++11)(until C++23)
   get_pointer_safety
   (C++11)(until C++23)
   Uninitialized storage
   raw_storage_iterator
   (until C++20*)
   get_temporary_buffer
   (until C++20*)
   return_temporary_buffer
   (until C++20*)
   Explicit lifetime management
   start_lifetime_asstart_lifetime_as_array
   (C++23)(C++23)
   Smart pointers
   unique_ptr
   (C++11)
   shared_ptr
   (C++11)
   weak_ptr
   (C++11)
   auto_ptr
   (until C++17*)
   owner_less
   (C++11)
   owner_less<void>
   (C++17)
   owner_hash
   (C++26)
   owner_equal
   (C++26)
   enable_shared_from_this
   (C++11)
   bad_weak_ptr
   (C++11)
   default_delete
   (C++11)
   out_ptr_t
   (C++23)
   inout_ptr_t
   (C++23)
   Low level memory
   management
   operator new
   operator new[]
   operator delete
   operator delete[]
   get_new_handler
   set_new_handler
   launder
   (C++17)
   bad_alloc
   bad_array_new_length
   nothrow_t
   align_val_t
   destroying_delete_t
   new_handler
   nothrow
   Miscellaneous
   pointer_traits
   (C++11)
   to_address
   (C++20)
   addressof
   (C++11)
   align
   (C++11)
   assume_aligned
   (C++20)
   C Library
   malloc
   calloc
   realloc

   aligned_alloc
   (C++17)
   free

   std::pmr::monotonic_buffer_resource
   monotonic_buffer_resource::monotonic_buffer_resource
   monotonic_buffer_resource::~monotonic_buffer_resource
   Public member functions
   monotonic_buffer_resource::release
   monotonic_buffer_resource::upstream_resource
   Protected member functions
   monotonic_buffer_resource::do_allocate
   monotonic_buffer_resource::do_deallocate
   monotonic_buffer_resource::do_is_equal

   Defined in header <memory_resource>
   class monotonic_buffer_resource : public std::pmr::memory_resource;
   (since C++17)

   The class std::pmr::monotonic_buffer_resource is a special-purpose
   memory resource class that releases the allocated memory only when the
   resource is destroyed. It is intended for very fast memory allocations
   in situations where memory is used to build up a few objects and then
   is released all at once.

   monotonic_buffer_resource can be constructed with an initial buffer. If
   there is no initial buffer, or if the buffer is exhausted, additional
   buffers are obtained from an upstream memory resource supplied at
   construction. The size of buffers obtained follows a geometric
   progression.

   monotonic_buffer_resource is not thread-safe.

Member functions

   (constructor)
   constructs a monotonic_buffer_resource
   (public member function)
   (destructor)
   [virtual]
   destroys a monotonic_buffer_resource, releasing all allocated memory
   (virtual public member function)
   operator=
   [deleted]
   copy assignment operator is deleted. monotonic_buffer_resource is not
   copy assignable
   (public member function)

Public member functions

   release
   release all allocated memory
   (public member function)
   upstream_resource
   returns a pointer to the upstream memory resource
   (public member function)

Protected member functions

   do_allocate
   [virtual]
   allocate memory
   (virtual protected member function)
   do_deallocate
   [virtual]
   no-op
   (virtual protected member function)
   do_is_equal
   [virtual]
   compare for equality with another std::pmr::memory_resource
   (virtual protected member function)

Example

   The program measures the time of creating huge double-linked lists
   using the following allocators:
     * default standard allocator,
     * default pmr allocator,
     * pmr allocator with monotonic resource but without explicit memory
       buffer,
     * pmr allocator with monotonic resource and external memory buffer
       (on stack).

   Run this code
#include <array>
#include <chrono>
#include <cstddef>
#include <iomanip>
#include <iostream>
#include <list>
#include <memory_resource>

template<typename Func>
auto benchmark(Func test_func, int iterations)
{
    const auto start = std::chrono::system_clock::now();
    while (iterations-- > 0)
        test_func();
    const auto stop = std::chrono::system_clock::now();
    const auto secs = std::chrono::duration<double>(stop - start);
    return secs.count();
}

int main()
{
    constexpr int iterations{100};
    constexpr int total_nodes{2'00'000};

    auto default_std_alloc = [total_nodes]
    {
        std::list<int> list;
        for (int i{}; i != total_nodes; ++i)
            list.push_back(i);
    };

    auto default_pmr_alloc = [total_nodes]
    {
        std::pmr::list<int> list;
        for (int i{}; i != total_nodes; ++i)
            list.push_back(i);
    };

    auto pmr_alloc_no_buf = [total_nodes]
    {
        std::pmr::monotonic_buffer_resource mbr;
        std::pmr::polymorphic_allocator<int> pa{&mbr};
        std::pmr::list<int> list{pa};
        for (int i{}; i != total_nodes; ++i)
            list.push_back(i);
    };

    auto pmr_alloc_and_buf = [total_nodes]
    {
        std::array<std::byte, total_nodes * 32> buffer; // enough to fit in all
nodes
        std::pmr::monotonic_buffer_resource mbr{buffer.data(), buffer.size()};
        std::pmr::polymorphic_allocator<int> pa{&mbr};
        std::pmr::list<int> list{pa};
        for (int i{}; i != total_nodes; ++i)
            list.push_back(i);
    };

    const double t1 = benchmark(default_std_alloc, iterations);
    const double t2 = benchmark(default_pmr_alloc, iterations);
    const double t3 = benchmark(pmr_alloc_no_buf , iterations);
    const double t4 = benchmark(pmr_alloc_and_buf, iterations);

    std::cout << std::fixed << std::setprecision(3)
              << "t1 (default std alloc): " << t1 << " sec; t1/t1: " << t1/t1 <<
 '\n'
              << "t2 (default pmr alloc): " << t2 << " sec; t1/t2: " << t1/t2 <<
 '\n'
              << "t3 (pmr alloc  no buf): " << t3 << " sec; t1/t3: " << t1/t3 <<
 '\n'
              << "t4 (pmr alloc and buf): " << t4 << " sec; t1/t4: " << t1/t4 <<
 '\n';
}

   Possible output:
t1 (default std alloc): 0.720 sec; t1/t1: 1.000
t2 (default pmr alloc): 0.915 sec; t1/t2: 0.787
t3 (pmr alloc  no buf): 0.370 sec; t1/t3: 1.945
t4 (pmr alloc and buf): 0.247 sec; t1/t4: 2.914

   Retrieved from
   "https://en.cppreference.com/mwiki/index.php?title=cpp/memory/monotonic
   _buffer_resource&oldid=152966"

Navigation

     * Online version
     * Offline version retrieved 2024-06-10 08:17.

     * This page was last modified on 8 June 2023, at 00:21.
     * This page has been accessed 87,602 times.
