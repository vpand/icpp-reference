std::beta, std::betaf, std::betal

   From cppreference.com
   < cpp | numeric | special functions

   C++
   Compiler support
   Freestanding and hosted
   Language
   Standard library
   Standard library headers
   Named requirements
   Feature test macros (C++20)
   Language support library
   Concepts library (C++20)
   Metaprogramming library (C++11)
   Diagnostics library
   General utilities library
   Strings library
   Containers library
   Iterators library
   Ranges library (C++20)
   Algorithms library
   Numerics library
   Localizations library
   Input/output library
   Filesystem library (C++17)
   Regular expressions library (C++11)
   Concurrency support library (C++11)
   Technical specifications
   Symbols index
   External libraries

   Numerics library
   Common mathematical functions
   Mathematical special functions (C++17)
   Mathematical constants (C++20)
   Basic linear algebra algorithms (C++26)
   Floating-point environment (C++11)
   Complex numbers
   Numeric arrays
   Pseudo-random number generation
   Factor operations
   gcd
   (C++17)
   lcm
   (C++17)
   Interpolations
   midpoint
   (C++20)
   lerp
   (C++20)
   Saturation arithmetic
   add_sat
   (C++26)
   sub_sat
   (C++26)
   saturate_cast
   (C++26)
   mul_sat
   (C++26)
   div_sat
   (C++26)
   Generic numeric operations
   iota
   (C++11)
   ranges::iota
   (C++23)
   accumulate
   inner_product
   adjacent_difference
   partial_sum
   reduce
   (C++17)
   transform_reduce
   (C++17)
   inclusive_scan
   (C++17)
   exclusive_scan
   (C++17)
   transform_inclusive_scan
   (C++17)
   transform_exclusive_scan
   (C++17)
   Bit operations
   has_single_bit
   (C++20)
   bit_cast
   (C++20)
   bit_ceil
   (C++20)
   bit_floor
   (C++20)
   bit_width
   (C++20)
   rotl
   (C++20)
   rotr
   (C++20)
   popcount
   (C++20)
   countl_zero
   (C++20)
   countl_one
   (C++20)
   countr_zero
   (C++20)
   countr_one
   (C++20)
   byteswap
   (C++23)
   endian
   (C++20)

   Mathematical special functions
   assoc_laguerreassoc_laguerrefassoc_laguerrel
   assoc_legendreassoc_legendrefassoc_legendrel
   betabetafbetal
   comp_ellint_1comp_ellint_1fcomp_ellint_1l
   comp_ellint_2comp_ellint_2fcomp_ellint_2l
   comp_ellint_3comp_ellint_3fcomp_ellint_3l
   cyl_bessel_icyl_bessel_ifcyl_bessel_il
   cyl_bessel_jcyl_bessel_jfcyl_bessel_jl
   cyl_bessel_kcyl_bessel_kfcyl_bessel_kl
   cyl_neumanncyl_neumannfcyl_neumannl
   ellint_1ellint_1fellint_1l
   ellint_2ellint_2fellint_2l
   ellint_3ellint_3fellint_3l
   expintexpintfexpintl
   hermitehermitefhermitel
   laguerrelaguerreflaguerrel
   legendrelegendreflegendrel
   riemann_zetariemann_zetafriemann_zetal
   sph_besselsph_besselfsph_bessell
   sph_legendresph_legendrefsph_legendrel
   sph_neumannsph_neumannfsph_neumannl

   Defined in header <cmath>
   (1)
   float       beta ( float x, float y );

   double      beta ( double x, double y );
   long double beta ( long double x, long double y );
   (since C++17)
   (until C++23)
   /* floating-point-type */ beta( /* floating-point-type */ x,
                                   /* floating-point-type */ y );
   (since C++23)
   float       betaf( float x, float y );
   (2) (since C++17)
   long double betal( long double x, long double y );
   (3) (since C++17)
   Additional overloads
   Defined in header <cmath>
   template< class Arithmetic1, class Arithmetic2 >
   /* common-floating-point-type */ beta( Arithmetic1 x, Arithmetic2 y );
   (A) (since C++17)
   1-3) Computes the Beta function of x and y. The library provides
   overloads of std::beta for all cv-unqualified floating-point types as
   the type of the parameters x and y.(since C++23)
   A) Additional overloads are provided for all other combinations of
   arithmetic types.

Parameters

   x, y - floating-point or integer values

Return value

   If no errors occur, value of the beta function of x and y, that is
   \(\int_{0}^{1}{ {t}^{x-1}{(1-t)}^{y-1}\mathsf{d}t}\)\int 1
   0tx-1
   (1-t)(y-1)
   dt, or, equivalently, \(\frac{\Gamma(x)\Gamma(y)}{\Gamma(x+y)}\)
   G(x)G(y)
   G(x+y)
   is returned.

Error handling

   Errors may be reported as specified in math_errhandling.
     * If any argument is NaN, NaN is returned and domain error is not
       reported.
     * The function is only required to be defined where both x and y are
       greater than zero, and is allowed to report a domain error
       otherwise.

Notes

   Implementations that do not support C++17, but support ISO 29124:2010,
   provide this function if __STDCPP_MATH_SPEC_FUNCS__ is defined by the
   implementation to a value at least 201003L and if the user defines
   __STDCPP_WANT_MATH_SPEC_FUNCS__ before including any standard library
   headers.

   Implementations that do not support ISO 29124:2010 but support TR
   19768:2007 (TR1), provide this function in the header tr1/cmath and
   namespace std::tr1.

   An implementation of this function is also available in boost.math.

   std::beta(x, y) equals std::beta(y, x).
   When x and y are positive integers, std::beta(x, y) equals
   \(\frac{(x-1)!(y-1)!}{(x+y-1)!}\)
   (x-1)!(y-1)!
   (x+y-1)!
   . Binomial coefficients can be expressed in terms of the beta function:
   \(\binom{n}{k} = \frac{1}{(n+1)B(n-k+1,k+1)}\)
   n
   k
    =
   1
   (n+1)B(n-k+1,k+1)
   .

   The additional overloads are not required to be provided exactly as
   (A). They only need to be sufficient to ensure that for their first
   argument num1 and second argument num2:
     * If num1 or num2 has type long double, then std::beta(num1, num2)
       has the same effect as std::beta(static_cast<long double>(num1),
                 static_cast<long double>(num2)).
     * Otherwise, if num1 and/or num2 has type double or an integer type,
       then std::beta(num1, num2) has the same effect as
       std::beta(static_cast<double>(num1),
                 static_cast<double>(num2)).
     * Otherwise, if num1 or num2 has type float, then std::beta(num1,
       num2) has the same effect as std::beta(static_cast<float>(num1),
                 static_cast<float>(num2)).

   (until C++23)

   If num1 and num2 have arithmetic types, then std::beta(num1, num2) has
   the same effect as std::beta(static_cast</* common-floating-point-type
   */>(num1),
             static_cast</* common-floating-point-type */>(num2)), where
   /* common-floating-point-type */ is the floating-point type with the
   greatest floating-point conversion rank and greatest floating-point
   conversion subrank between the types of num1 and num2, arguments of
   integer type are considered to have the same floating-point conversion
   rank as double.

   If no such floating-point type with the greatest rank and subrank
   exists, then overload resolution does not result in a usable candidate
   from the overloads provided.
   (since C++23)

Example

   Run this code
#include <cassert>
#include <cmath>
#include <iomanip>
#include <iostream>
#include <numbers>
#include <string>

long binom_via_beta(int n, int k)
{
    return std::lround(1 / ((n + 1) * std::beta(n - k + 1, k + 1)));
}

long binom_via_gamma(int n, int k)
{
    return std::lround(std::tgamma(n + 1) /
                      (std::tgamma(n - k + 1) *
                       std::tgamma(k + 1)));
}

int main()
{
    std::cout << "Pascal's triangle:\n";
    for (int n = 1; n < 10; ++n)
    {
        std::cout << std::string(20 - n * 2, ' ');
        for (int k = 1; k < n; ++k)
        {
            std::cout << std::setw(3) << binom_via_beta(n, k) << ' ';
            assert(binom_via_beta(n, k) == binom_via_gamma(n, k));
        }
        std::cout << '\n';
    }

    // A spot-check
    const long double p = 0.123; // a random value in [0, 1]
    const long double q = 1 - p;
    const long double p = std::numbers::pi_v<long double>;
    std::cout << "\n\n" << std::setprecision(19)
              << "b(p,1-p)   = " << std::beta(p, q) << '\n'
              << "p/sin(p*p) = " << p / std::sin(p * p) << '\n';
}

   Output:
Pascal's triangle:

                  2
                3   3
              4   6   4
            5  10  10   5
          6  15  20  15   6
        7  21  35  35  21   7
      8  28  56  70  56  28   8
    9  36  84 126 126  84  36   9

b(p,1-p)   = 8.335989149587307836
p/sin(p*p) = 8.335989149587307834

See also

   tgammatgammaftgammal
   (C++11)(C++11)(C++11)
   gamma function
   (function)

External links

   Weisstein, Eric W. "Beta Function." From MathWorld -- A Wolfram Web
   Resource.
   Retrieved from
   "https://en.cppreference.com/mwiki/index.php?title=cpp/numeric/special_
   functions/beta&oldid=160789"

Navigation

     * Online version
     * Offline version retrieved 2024-06-10 08:17.

     * This page was last modified on 17 October 2023, at 00:35.
     * This page has been accessed 38,650 times.
