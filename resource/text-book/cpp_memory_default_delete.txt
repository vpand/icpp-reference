std::default_delete

   From cppreference.com
   < cpp | memory

   C++
   Compiler support
   Freestanding and hosted
   Language
   Standard library
   Standard library headers
   Named requirements
   Feature test macros (C++20)
   Language support library
   Concepts library (C++20)
   Metaprogramming library (C++11)
   Diagnostics library
   General utilities library
   Strings library
   Containers library
   Iterators library
   Ranges library (C++20)
   Algorithms library
   Numerics library
   Localizations library
   Input/output library
   Filesystem library (C++17)
   Regular expressions library (C++11)
   Concurrency support library (C++11)
   Technical specifications
   Symbols index
   External libraries

   Utilities library
   Language support
   Type support (basic types, RTTI)
   Library feature-test macros (C++20)
   Dynamic memory management
   Program utilities
   Coroutine support (C++20)
   Variadic functions
   is_constant_evaluated
   (C++20)
   is_within_lifetime
   (C++26)
   initializer_list
   (C++11)
   source_location
   (C++20)
   Debugging support
   is_debugger_present
   (C++26)
   breakpoint_if_debugging
   (C++26)
   breakpoint
   (C++26)
   Three-way comparison
   three_way_comparablethree_way_comparable_with
   (C++20)(C++20)
   strong_ordering
   (C++20)
   weak_ordering
   (C++20)
   partial_ordering
   (C++20)
   common_comparison_category
   (C++20)
   compare_three_way_result
   (C++20)
   compare_three_way
   (C++20)
   strong_order
   (C++20)
   weak_order
   (C++20)
   partial_order
   (C++20)
   compare_strong_order_fallback
   (C++20)
   compare_weak_order_fallback
   (C++20)
   compare_partial_order_fallback
   (C++20)
   is_eqis_ltis_lteq
   (C++20)(C++20)(C++20)
   is_neqis_gtis_gteq
   (C++20)(C++20)(C++20)
   General utilities
   Date and time
   Function objects
   Formatting library (C++20)
   bitset
   hash
   (C++11)
   Relational operators (deprecated in C++20)
   rel_ops::operator!=rel_ops::operator>

   rel_ops::operator<=rel_ops::operator>=
   Integer comparison functions
   cmp_equalcmp_lesscmp_less_than
   (C++20)(C++20)(C++20)
   cmp_not_equalcmp_greatercmp_greater_than
   (C++20)(C++20)(C++20)
   in_range
   (C++20)
   Swap and type operations
   swap
   ranges::swap
   (C++20)
   exchange
   (C++14)
   declval
   (C++11)
   to_underlying
   (C++23)
   forward
   (C++11)
   forward_like
   (C++23)
   move
   (C++11)
   move_if_noexcept
   (C++11)
   as_const
   (C++17)
   Common vocabulary types
   pair
   tuple
   (C++11)
   optional
   (C++17)
   any
   (C++17)
   variant
   (C++17)
   tuple_size
   (C++11)
   tuple_element
   (C++11)
   apply
   (C++17)
   make_from_tuple
   (C++17)
   expected
   (C++23)
   Elementary string conversions
   to_chars
   (C++17)
   from_chars
   (C++17)
   chars_format
   (C++17)
   to_chars_result
   (C++17)
   from_chars_result
   (C++17)

   Dynamic memory management
   Uninitialized memory algorithms
   uninitialized_copy
   uninitialized_fill
   uninitialized_move
   (C++17)
   uninitialized_default_construct
   (C++17)
   uninitialized_value_construct
   (C++17)
   destroy
   (C++17)
   destroy_at
   (C++17)
   voidify
   (C++20)
   uninitialized_copy_n
   (C++11)
   uninitialized_fill_n
   uninitialized_move_n
   (C++17)
   uninitialized_default_construct_n
   (C++17)
   uninitialized_value_construct_n
   (C++17)
   destroy_n
   (C++17)
   construct_at
   (C++20)
   Constrained uninitialized memory algorithms
   ranges::uninitialized_copy
   (C++20)
   ranges::uninitialized_fill
   (C++20)
   ranges::uninitialized_move
   (C++20)
   ranges::construct_at
   (C++20)
   ranges::destroy
   (C++20)
   ranges::destroy_n
   (C++20)
   ranges::destroy_at
   (C++20)
   ranges::uninitialized_copy_n
   (C++20)
   ranges::uninitialized_fill_n
   (C++20)
   ranges::uninitialized_move_n
   (C++20)
   ranges::uninitialized_default_construct
   (C++20)
   ranges::uninitialized_value_construct
   (C++20)
   ranges::uninitialized_default_construct_n
   (C++20)
   ranges::uninitialized_value_construct_n
   (C++20)
   Allocators
   allocator
   allocator_traits
   (C++11)
   allocation_result
   (C++23)
   allocator_arg
   (C++11)
   uses_allocator
   (C++11)
   uses_allocator_construction_args
   (C++20)
   make_obj_using_allocator
   (C++20)
   uninitialized_construct_using_allocator
   (C++20)
   scoped_allocator_adaptor
   (C++11)
   pmr::polymorphic_allocator
   (C++17)
   Memory resources
   pmr::memory_resource
   (C++17)
   pmr::get_default_resource
   (C++17)
   pmr::set_default_resource
   (C++17)
   pmr::new_delete_resource
   (C++17)
   pmr::null_memory_resource
   (C++17)
   pmr::synchronized_pool_resource
   (C++17)
   pmr::unsynchronized_pool_resource
   (C++17)
   pmr::monotonic_buffer_resource
   (C++17)
   pmr::pool_options
   (C++17)
   Garbage collection support
   declare_reachable
   (C++11)(until C++23)
   undeclare_reachable
   (C++11)(until C++23)
   declare_no_pointers
   (C++11)(until C++23)
   undeclare_no_pointers
   (C++11)(until C++23)
   pointer_safety
   (C++11)(until C++23)
   get_pointer_safety
   (C++11)(until C++23)
   Uninitialized storage
   raw_storage_iterator
   (until C++20*)
   get_temporary_buffer
   (until C++20*)
   return_temporary_buffer
   (until C++20*)
   Explicit lifetime management
   start_lifetime_asstart_lifetime_as_array
   (C++23)(C++23)
   Smart pointers
   unique_ptr
   (C++11)
   shared_ptr
   (C++11)
   weak_ptr
   (C++11)
   auto_ptr
   (until C++17*)
   owner_less
   (C++11)
   owner_less<void>
   (C++17)
   owner_hash
   (C++26)
   owner_equal
   (C++26)
   enable_shared_from_this
   (C++11)
   bad_weak_ptr
   (C++11)
   default_delete
   (C++11)
   out_ptr_t
   (C++23)
   inout_ptr_t
   (C++23)
   Low level memory
   management
   operator new
   operator new[]
   operator delete
   operator delete[]
   get_new_handler
   set_new_handler
   launder
   (C++17)
   bad_alloc
   bad_array_new_length
   nothrow_t
   align_val_t
   destroying_delete_t
   new_handler
   nothrow
   Miscellaneous
   pointer_traits
   (C++11)
   to_address
   (C++20)
   addressof
   (C++11)
   align
   (C++11)
   assume_aligned
   (C++20)
   C Library
   malloc
   calloc
   realloc

   aligned_alloc
   (C++17)
   free

   std::default_delete

   Defined in header <memory>
   template< class T > struct default_delete;
   (1)                                            (since C++11)
   template< class T > struct default_delete<T[]>;
   (2)                                            (since C++11)

   std::default_delete is the default destruction policy used by
   std::unique_ptr when no deleter is specified. Specializations of
   default_delete are empty classes on typical implementations, and used
   in the empty base class optimization.
   1) The non-specialized default_delete uses delete to deallocate memory
   for a single object.
   2) A partial specialization for array types that uses delete[] is also
   provided.

Member functions

   (constructor)
   constructs a default_delete object
   (public member function)
   operator()
   deletes the object or array
   (public member function)

std::default_delete::default_delete

   constexpr default_delete() noexcept = default;
   (1)
   Primary template specializations
   template< class U >
   default_delete( const default_delete<U>& d ) noexcept;
   (2) (since C++11)
   (constexpr since C++23)
   Array specializations
   template< class U >
   default_delete( const default_delete<U[]>& d ) noexcept;
   (3) (since C++11)
   (constexpr since C++23)
   1) Constructs a std::default_delete object.
   2) Constructs a std::default_delete<T> object from another
   std::default_delete object.
   This overload participates in overload resolution only if U* is
   implicitly convertible to T*.
   3) Constructs a std::default_delete<T[]> object from another
   std::default_delete<U[]> object.
   This overload participates in overload resolution only if U(*)[] is
   implicitly convertible to T(*)[].

Parameters

   d - a deleter to copy from

Notes

   The converting constructor template of std::default_delete makes
   possible the implicit conversion from std::unique_ptr<Derived> to
   std::unique_ptr<Base>.

std::default_delete::operator()

   Primary template specializations
   void operator()( T* ptr ) const;
   (1) (since C++11)
   (constexpr since C++23)
   Array specializations
   template< class U >
   void operator()( U* ptr ) const;
   (2) (since C++11)
   (constexpr since C++23)
   1) Calls delete on ptr.
   2) Calls delete[] on ptr.
   This overload participates in overload resolution only if U(*)[] is
   implicitly convertible to T(*)[].
   If U is an incomplete type, the program is ill-formed.

Parameters

   ptr - an object or array to delete

Exceptions

   No exception guarantees.

Invoking over Incomplete Types

   At the point in the code the operator() is called, the type must be
   complete. In some implementations a static_assert is used to make sure
   this is the case. The reason for this requirement is that calling
   delete on an incomplete type is undefined behavior in C++ if the
   complete class type has a nontrivial destructor or a deallocation
   function, as the compiler has no way of knowing whether such functions
   exist and must be invoked.

Notes

   Feature-test macro Value Std Feature
   __cpp_lib_constexpr_memory 202202L (C++23) constexpr constructor and
   operator()

Example

   Run this code
#include <algorithm>
#include <memory>
#include <vector>

int main()
{
//  {
//      std::shared_ptr<int> shared_bad(new int[10]);
//  } // the destructor calls delete, undefined behavior

    {
        std::shared_ptr<int> shared_good(new int[10], std::default_delete<int[]>
());
    } // OK: the destructor calls delete[]

    {
        std::unique_ptr<int> ptr(new int(5));
    } // unique_ptr<int> uses default_delete<int>

    {
        std::unique_ptr<int[]> ptr(new int[10]);
    } // unique_ptr<int[]> uses default_delete<int[]>

    // default_delete can be used anywhere a delete functor is needed
    std::vector<int*> v;
    for (int n = 0; n < 100; ++n)
        v.push_back(new int(n));
    std::for_each(v.begin(), v.end(), std::default_delete<int>());
}

Defect reports

   The following behavior-changing defect reports were applied
   retroactively to previously published C++ standards.
   DR Applied to Behavior as published Correct behavior
   LWG 2118 C++11 member functions of the array specializations rejected
   qualification conversions accept

See also

   unique_ptr
   (C++11)
   smart pointer with unique object ownership semantics
   (class template)
   Retrieved from
   "https://en.cppreference.com/mwiki/index.php?title=cpp/memory/default_d
   elete&oldid=170056"

Navigation

     * Online version
     * Offline version retrieved 2024-06-10 08:17.

     * This page was last modified on 3 March 2024, at 22:48.
     * This page has been accessed 224,916 times.
