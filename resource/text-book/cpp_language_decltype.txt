decltype specifier

   From cppreference.com
   < cpp | language

   C++
   Compiler support
   Freestanding and hosted
   Language
   Standard library
   Standard library headers
   Named requirements
   Feature test macros (C++20)
   Language support library
   Concepts library (C++20)
   Metaprogramming library (C++11)
   Diagnostics library
   General utilities library
   Strings library
   Containers library
   Iterators library
   Ranges library (C++20)
   Algorithms library
   Numerics library
   Localizations library
   Input/output library
   Filesystem library (C++17)
   Regular expressions library (C++11)
   Concurrency support library (C++11)
   Technical specifications
   Symbols index
   External libraries

   C++ language
   General topics
   Preprocessor
   Comments
   Keywords
   Escape sequences
   Flow control
   Conditional execution statements
   if
   switch
   Iteration statements (loops)
   for
   range-for (C++11)
   while
   do-while
   Jump statements
   continue - break
   goto - return
   Functions
   Function declaration
   Lambda function expression
   inline specifier
   Dynamic exception specifications (until C++17*)
   noexcept specifier (C++11)
   Exceptions
   throw-expression
   try block
   handler
   Namespaces
   Namespace declaration
   Namespace aliases
   Types
   Fundamental types
   Enumeration types
   Function types
   Class/struct types
   Union types
   Specifiers
   const/volatile
   decltype (C++11)
   auto (C++11)
   constexpr (C++11)
   consteval (C++20)
   constinit (C++20)
   Storage duration specifiers
   Initialization
   Default-initialization
   Value-initialization
   Zero-initialization
   Copy-initialization
   Direct-initialization
   Aggregate initialization
   List-initialization (C++11)
   Constant initialization
   Reference initialization
   Expressions
   Value categories
   Order of evaluation
   Operators
   Operator precedence
   Alternative representations
   Literals
   Boolean - Integer - Floating-point
   Character - String - nullptr (C++11)
   User-defined (C++11)
   Utilities
   Attributes (C++11)
   Types
   typedef declaration
   Type alias declaration (C++11)
   Casts
   Implicit conversions
   static_cast
   const_cast
   Explicit conversions
   dynamic_cast
   reinterpret_cast
   Memory allocation
   new expression
   delete expression
   Classes
   Class declaration
   Constructors
   this pointer
   Access specifiers
   friend specifier
   Class-specific function properties
   Virtual function
   override specifier (C++11)
   final specifier (C++11)
   explicit (C++11)
   static
   Special member functions
   Default constructor
   Copy constructor
   Move constructor (C++11)
   Copy assignment
   Move assignment (C++11)
   Destructor
   Templates
   Class template
   Function template
   Template specialization
   Parameter packs (C++11)
   Miscellaneous
   Inline assembly
   History of C++

   Declarations
   Overview
   Declaration syntax
   decl-specifier-seq
   Declarator
   Conflicting declarations
   Specifiers
   typedef
   inline
   virtual function specifier
   explicit function specifier
   friend
   constexpr
   (C++11)
   consteval
   (C++20)
   constinit
   (C++20)
   Storage class specifiers
   Translation-unit-local (C++20)
   class/struct
   union
   enum
   decltype
   (C++11)
   auto
   (C++11)
   alignas
   (C++11)
   constvolatile
   Pack indexing specifier (C++26)
   Elaborated type specifier
   Attributes (C++11)
   Declarators
   Reference
   Pointer
   Array
   Block declarations
   Simple-declaration
   ->Structured binding declaration (C++17)
   Alias declaration (C++11)
   Namespace alias definition
   using declaration
   using directive
   static_assert declaration (C++11)
   asm declaration
   Opaque enum declaration (C++11)
   Other declarations
   Namespace definition
   Function declaration
   Class template declaration
   Function template declaration
   Explicit template instantiation (C++11)
   Explicit template specialization
   Linkage specification
   Attribute declaration (C++11)
   Empty declaration

   Inspects the declared type of an entity or the type and value category
   of an expression.

Syntax

   decltype ( entity )     (1) (since C++11)
   decltype ( expression ) (2) (since C++11)

Explanation

   1) If the argument is an unparenthesized id-expression or an
   unparenthesized class member access expression, then decltype yields
   the type of the entity named by this expression. If there is no such
   entity, or if the argument names a set of overloaded functions, the
   program is ill-formed.

   If the argument is an unparenthesized id-expression naming a structured
   binding, then decltype yields the referenced type (described in the
   specification of the structured binding declaration).
   (since C++17)

   If the argument is an unparenthesized id-expression naming a non-type
   template parameter, then decltype yields the type of the template
   parameter (after performing any necessary type deduction if the
   template parameter is declared with a placeholder type). The type is
   non-const even if the entity is a template parameter object (which is a
   const object).
   (since C++20)
   2) If the argument is any other expression of type T, and
   a) if the value category of expression is xvalue, then decltype yields
   T&&;
   b) if the value category of expression is lvalue, then decltype yields
   T&;
   c) if the value category of expression is prvalue, then decltype yields
   T.

   If expression is a function call which returns a prvalue of class type
   or is a comma expression whose right operand is such a function call, a
   temporary object is not introduced for that prvalue.
   (until C++17)

   If expression is a prvalue other than a (possibly parenthesized)
   immediate invocation(since C++20), a temporary object is not
   materialized from that prvalue: such prvalue has no result object.
   (since C++17)
   Because no temporary object is created, the type need not be complete
   or have an available destructor, and can be abstract. This rule doesn't
   apply to sub-expressions: in decltype(f(g())), g() must have a complete
   type, but f() need not.

   Note that if the name of an object is parenthesized, it is treated as
   an ordinary lvalue expression, thus decltype(x) and decltype((x)) are
   often different types.

   decltype is useful when declaring types that are difficult or
   impossible to declare using standard notation, like lambda-related
   types or types that depend on template parameters.

Notes

   Feature-test macro  Value    Std   Feature
   __cpp_decltype     200707L (C++11) decltype

Keywords

   decltype

Example

   Run this code
#include <cassert>
#include <iostream>
#include <type_traits>

struct A { double x; };
const A* a;

decltype(a->x) y;       // type of y is double (declared type)
decltype((a->x)) z = y; // type of z is const double& (lvalue expression)

template<typename T, typename U>
auto add(T t, U u) -> decltype(t + u) // return type depends on template paramet
ers
                                      // return type can be deduced since C++14
{
    return t + u;
}

const int& getRef(const int* p) { return *p; }
static_assert(std::is_same_v<decltype(getRef), const int&(const int*)>);
auto getRefFwdBad(const int* p) { return getRef(p); }
static_assert(std::is_same_v<decltype(getRefFwdBad), int(const int*)>,
    "Just returning auto isn't perfect forwarding.");
decltype(auto) getRefFwdGood(const int* p) { return getRef(p); }
static_assert(std::is_same_v<decltype(getRefFwdGood), const int&(const int*)>,
    "Returning decltype(auto) perfectly forwards the return type.");

// Alternatively:
auto getRefFwdGood1(const int* p) -> decltype(getRef(p)) { return getRef(p); }
static_assert(std::is_same_v<decltype(getRefFwdGood1), const int&(const int*)>,
    "Returning decltype(return expression) also perfectly forwards the return ty
pe.");

int main()
{
    int i = 33;
    decltype(i) j = i * 2;
    static_assert(std::is_same_v<decltype(i), decltype(j)>);
    assert(i == 33 && 66 == j);

    auto f = [i](int av, int bv) -> int { return av * bv + i; };
    auto h = [i](int av, int bv) -> int { return av * bv + i; };
    static_assert(!std::is_same_v<decltype(f), decltype(h)>,
        "The type of a lambda function is unique and unnamed");

    decltype(f) g = f;
    std::cout << f(3, 3) << ' ' << g(3, 3) << '\n';
}

   Output:
42 42

References

              Extended content
     * C++23 standard (ISO/IEC 14882:2023):

          + 9.2.9.5 Decltype specifiers [dcl.type.decltype]

     * C++20 standard (ISO/IEC 14882:2020):

          + TBD Decltype specifiers [dcl.type.decltype]

     * C++17 standard (ISO/IEC 14882:2017):

          + TBD Decltype specifiers [dcl.type.decltype]

     * C++14 standard (ISO/IEC 14882:2014):

          + TBD Decltype specifiers [dcl.type.decltype]

     * C++11 standard (ISO/IEC 14882:2011):

          + TBD Decltype specifiers [dcl.type.decltype]

See also

   auto specifier (C++11) specifies a type deduced from an expression
   declval
   (C++11)
   obtains a reference to its argument for use in unevaluated context
   (function template)
   is_same
   (C++11)
   checks if two types are the same
   (class template)
   Retrieved from
   "https://en.cppreference.com/mwiki/index.php?title=cpp/language/decltyp
   e&oldid=170123"

Navigation

     * Online version
     * Offline version retrieved 2024-06-10 08:17.

     * This page was last modified on 10 March 2024, at 09:41.
     * This page has been accessed 1,295,503 times.
