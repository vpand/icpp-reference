std::shared_mutex

   From cppreference.com
   < cpp | thread

   C++
   Compiler support
   Freestanding and hosted
   Language
   Standard library
   Standard library headers
   Named requirements
   Feature test macros (C++20)
   Language support library
   Concepts library (C++20)
   Metaprogramming library (C++11)
   Diagnostics library
   General utilities library
   Strings library
   Containers library
   Iterators library
   Ranges library (C++20)
   Algorithms library
   Numerics library
   Localizations library
   Input/output library
   Filesystem library (C++17)
   Regular expressions library (C++11)
   Concurrency support library (C++11)
   Technical specifications
   Symbols index
   External libraries

   Concurrency support library
   Threads
   thread
   (C++11)
   jthread
   (C++20)
   stop_token
   (C++20)
   stop_source
   (C++20)
   stop_callback
   (C++20)
   hardware_destructive_interference_sizehardware_constructive_interferenc
   e_size
   (C++17)(C++17)
   this_thread namespace
   get_id
   (C++11)
   yield
   (C++11)
   sleep_for
   (C++11)
   sleep_until
   (C++11)
   Mutual exclusion
   mutex
   (C++11)
   recursive_mutex
   (C++11)
   shared_mutex
   (C++17)
   timed_mutex
   (C++11)
   recursive_timed_mutex
   (C++11)
   shared_timed_mutex
   (C++14)
   Generic lock management
   lock_guard
   (C++11)
   scoped_lock
   (C++17)
   unique_lock
   (C++11)
   shared_lock
   (C++14)
   defer_lock_ttry_to_lock_tadopt_lock_t
   (C++11)(C++11)(C++11)
   lock
   (C++11)
   try_lock
   (C++11)
   defer_locktry_to_lockadopt_lock
   (C++11)(C++11)(C++11)
   once_flag
   (C++11)
   call_once
   (C++11)
   Condition variables
   condition_variable
   (C++11)
   condition_variable_any
   (C++11)
   notify_all_at_thread_exit
   (C++11)
   cv_status
   (C++11)
   Semaphores
   counting_semaphorebinary_semaphore
   (C++20)(C++20)
   Latches and Barriers
   latch
   (C++20)
   barrier
   (C++20)
   Futures
   promise
   (C++11)
   future
   (C++11)
   shared_future
   (C++11)
   packaged_task
   (C++11)
   async
   (C++11)
   launch
   (C++11)
   future_status
   (C++11)
   future_error
   (C++11)
   future_category
   (C++11)
   future_errc
   (C++11)
   Safe Reclamation
   rcu_obj_base
   (C++26)
   rcu_domain
   (C++26)
   rcu_default_domain
   (C++26)
   rcu_synchronize
   (C++26)
   rcu_barrier
   (C++26)
   rcu_retire
   (C++26)
   Hazard Pointers
   hazard_pointer_obj_base
   (C++26)
   hazard_pointer
   (C++26)
   make_hazard_pointer
   (C++26)
   Atomic types
   atomic
   (C++11)
   atomic_ref
   (C++20)
   atomic_flag
   (C++11)
   Initialization of atomic types
   atomic_init
   (C++11)(deprecated in C++20)
   ATOMIC_VAR_INIT
   (C++11)(deprecated in C++20)
   ATOMIC_FLAG_INIT
   (C++11)
   Memory ordering
   memory_order
   (C++11)
   kill_dependency
   (C++11)
   atomic_thread_fence
   (C++11)
   atomic_signal_fence
   (C++11)
   Free functions for atomic operations
   atomic_storeatomic_store_explicit
   (C++11)(C++11)
   atomic_loadatomic_load_explicit
   (C++11)(C++11)
   atomic_exchangeatomic_exchange_explicit
   (C++11)(C++11)
   atomic_compare_exchange_weakatomic_compare_exchange_weak_explicitatomic
   _compare_exchange_strongatomic_compare_exchange_strong_explicit
   (C++11)(C++11)(C++11)(C++11)
   atomic_fetch_addatomic_fetch_add_explicit
   (C++11)(C++11)
   atomic_fetch_subatomic_fetch_sub_explicit
   (C++11)(C++11)
   atomic_fetch_andatomic_fetch_and_explicit
   (C++11)(C++11)
   atomic_fetch_oratomic_fetch_or_explicit
   (C++11)(C++11)
   atomic_fetch_xoratomic_fetch_xor_explicit
   (C++11)(C++11)
   atomic_fetch_maxatomic_fetch_max_explicit
   (C++26)(C++26)
   atomic_fetch_minatomic_fetch_min_explicit
   (C++26)(C++26)
   atomic_is_lock_free
   (C++11)
   atomic_waitatomic_wait_explicit
   (C++20)(C++20)
   atomic_notify_one
   (C++20)
   atomic_notify_all
   (C++20)
   Free functions for atomic flags
   atomic_flag_test_and_setatomic_flag_test_and_set_explicit
   (C++11)(C++11)
   atomic_flag_clearatomic_flag_clear_explicit
   (C++11)(C++11)
   atomic_flag_testatomic_flag_test_explicit
   (C++20)(C++20)
   atomic_flag_waitatomic_flag_wait_explicit
   (C++20)(C++20)
   atomic_flag_notify_one
   (C++20)
   atomic_flag_notify_all
   (C++20)

   std::shared_mutex
   Member functions
   shared_mutex::shared_mutex
   shared_mutex::~shared_mutex
   Exclusive locking
   shared_mutex::lock
   shared_mutex::try_lock
   shared_mutex::unlock
   Shared locking
   shared_mutex::lock_shared
   shared_mutex::try_lock_shared
   shared_mutex::unlock_shared
   Native handle
   shared_mutex::native_handle

   Defined in header <shared_mutex>
   class shared_mutex;
                                   (since C++17)

   The shared_mutex class is a synchronization primitive that can be used
   to protect shared data from being simultaneously accessed by multiple
   threads. In contrast to other mutex types which facilitate exclusive
   access, a shared_mutex has two levels of access:
     * shared - several threads can share ownership of the same mutex.

     * exclusive - only one thread can own the mutex.

   If one thread has acquired the exclusive lock (through lock, try_lock),
   no other threads can acquire the lock (including the shared).

   If one thread has acquired the shared lock (through lock_shared,
   try_lock_shared), no other thread can acquire the exclusive lock, but
   can acquire the shared lock.

   Only when the exclusive lock has not been acquired by any thread, the
   shared lock can be acquired by multiple threads.

   Within one thread, only one lock (shared or exclusive) can be acquired
   at the same time.

   Shared mutexes are especially useful when shared data can be safely
   read by any number of threads simultaneously, but a thread may only
   write the same data when no other thread is reading or writing at the
   same time.

   The shared_mutex class satisfies all requirements of SharedMutex and
   StandardLayoutType.

Member types

   Member type                    Definition
   native_handle_type (optional*) implementation-defined

Member functions

   (constructor)
   constructs the mutex
   (public member function)
   (destructor)
   destroys the mutex
   (public member function)
   operator=
   [deleted]
   not copy-assignable
   (public member function)

Exclusive locking

   lock
   locks the mutex, blocks if the mutex is not available
   (public member function)
   try_lock
   tries to lock the mutex, returns if the mutex is not available
   (public member function)
   unlock
   unlocks the mutex
   (public member function)

Shared locking

   lock_shared
   locks the mutex for shared ownership, blocks if the mutex is not
   available
   (public member function)
   try_lock_shared
   tries to lock the mutex for shared ownership, returns if the mutex is
   not available
   (public member function)
   unlock_shared
   unlocks the mutex (shared ownership)
   (public member function)

Native handle

   native_handle
   returns the underlying implementation-defined native handle object
   (public member function)

Example

   The output below was generated on a single-core machine. When thread1
   starts, it enters the loop for the first time and calls increment()
   followed by get(). However, before it can print the returned value to
   std::cout, the scheduler puts thread1 to sleep and wakes up thread2,
   which obviously has time enough to run all three loop iterations at
   once. Back to thread1, still in the first loop iteration, it finally
   prints its local copy of the counter's value, which is 1, to std::cout
   and then runs the remaining two loop iterations. On a multi-core
   machine, none of the threads is put to sleep and the output is more
   likely to be in ascending order.
   Run this code
#include <iostream>
#include <mutex>
#include <shared_mutex>
#include <syncstream>
#include <thread>

class ThreadSafeCounter
{
public:
    ThreadSafeCounter() = default;

    // Multiple threads/readers can read the counter's value at the same time.
    unsigned int get() const
    {
        std::shared_lock lock(mutex_);
        return value_;
    }

    // Only one thread/writer can increment/write the counter's value.
    void increment()
    {
        std::unique_lock lock(mutex_);
        ++value_;
    }

    // Only one thread/writer can reset/write the counter's value.
    void reset()
    {
        std::unique_lock lock(mutex_);
        value_ = 0;
    }

private:
    mutable std::shared_mutex mutex_;
    unsigned int value_{};
};

int main()
{
    ThreadSafeCounter counter;

    auto increment_and_print = [&counter]()
    {
        for (int i{}; i != 3; ++i)
        {
            counter.increment();
            std::osyncstream(std::cout)
                << std::this_thread::get_id() << ' ' << counter.get() << '\n';
        }
    };

    std::thread thread1(increment_and_print);
    std::thread thread2(increment_and_print);

    thread1.join();
    thread2.join();
}

   Possible output:
123084176803584 2
123084176803584 3
123084176803584 4
123084185655040 1
123084185655040 5
123084185655040 6

See also

   shared_timed_mutex
   (C++14)
   provides shared mutual exclusion facility and implements locking with a
   timeout
   (class)
   shared_lock
   (C++14)
   implements movable shared mutex ownership wrapper
   (class template)
   unique_lock
   (C++11)
   implements movable mutex ownership wrapper
   (class template)
   Retrieved from
   "https://en.cppreference.com/mwiki/index.php?title=cpp/thread/shared_mu
   tex&oldid=153276"

Navigation

     * Online version
     * Offline version retrieved 2024-06-10 08:17.

     * This page was last modified on 13 June 2023, at 06:06.
     * This page has been accessed 573,263 times.
