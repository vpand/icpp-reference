C++ named requirements: CopyConstructible

   From cppreference.com
   < cpp | named req

   C++
   Compiler support
   Freestanding and hosted
   Language
   Standard library
   Standard library headers
   Named requirements
   Feature test macros (C++20)
   Language support library
   Concepts library (C++20)
   Metaprogramming library (C++11)
   Diagnostics library
   General utilities library
   Strings library
   Containers library
   Iterators library
   Ranges library (C++20)
   Algorithms library
   Numerics library
   Localizations library
   Input/output library
   Filesystem library (C++17)
   Regular expressions library (C++11)
   Concurrency support library (C++11)
   Technical specifications
   Symbols index
   External libraries

   C++ named requirements
   Basic
   DefaultConstructible
   CopyAssignable
   CopyConstructible
   MoveAssignable
   (C++11)
   MoveConstructible
   (C++11)
   Destructible
   Type properties
   ScalarType
   TriviallyCopyable
   (C++11)
   StandardLayoutType
   (C++11)
   PODType
   TrivialType
   (C++11)
   ImplicitLifetimeType
   Library-Wide
   EqualityComparable
   LessThanComparable
   Swappable
   ValueSwappable
   (C++11)
   NullablePointer
   (C++11)
   Hash
   (C++11)
   Allocator
   FunctionObject
   Callable
   Predicate
   BinaryPredicate
   Compare
   Container
   Container
   SequenceContainer
   ContiguousContainer
   (C++17)
   ReversibleContainer
   AssociativeContainer
   AllocatorAwareContainer
   UnorderedAssociativeContainer
   (C++11)
   Container Elements
   DefaultInsertable
   (C++11)
   CopyInsertable
   (C++11)
   MoveInsertable
   (C++11)
   EmplaceConstructible
   (C++11)
   Erasable
   (C++11)
   Iterator
   LegacyIterator
   LegacyOutputIterator
   LegacyInputIterator
   LegacyForwardIterator
   LegacyBidirectionalIterator
   LegacyRandomAccessIterator
   LegacyContiguousIterator
   (C++17)
   ConstexprIterator
   (C++20)
   Stream I/O
   FormattedInputFunction
   UnformattedInputFunction
   FormattedOutputFunction
   UnformattedOutputFunction
   Formatters
   BasicFormatter
   (C++20)
   Formatter
   (C++20)
   Random Numbers
   SeedSequence
   (C++11)
   RandomNumberEngine
   (C++11)
   RandomNumberDistribution
   (C++11)
   UniformRandomBitGenerator
   (C++11)
   RandomNumberEngineAdaptor
   (C++11)
   Concurrency
   BasicLockable
   (C++11)
   Lockable
   (C++11)
   TimedLockable
   (C++11)
   SharedLockable
   (C++14)
   SharedTimedLockable
   (C++14)
   Mutex
   (C++11)
   TimedMutex
   (C++11)
   SharedMutex
   (C++17)
   SharedTimedMutex
   (C++14)
   Ranges
   RangeAdaptorObject
   (C++20)
   RangeAdaptorClosureObject
   (C++20)
   Other
   CharTraits
   RegexTraits
   (C++11)
   BitmaskType
   LiteralType
   (C++11)
   NumericType
   UnaryTypeTrait
   (C++11)
   BinaryTypeTrait
   (C++11)
   TransformationTrait
   (C++11)
   Clock
   (C++11)
   TrivialClock
   (C++11)

   Specifies that an instance of the type can be copy-constructed from an
   lvalue expression.

Requirements

   The type T satisfies CopyConstructible if
     * The type T satisfies MoveConstructible, and

   Given
     * v, an lvalue expression of type T or const T or an rvalue
       expression of type const T,
     * u, an arbitrary identifier.

   The following expressions must be valid and have their specified
   effects:
   Expression Post-conditions
   T u = v; The value of u is equivalent to the value of v.

   The value of v is unchanged.
   T(v) The value of T(v) is equivalent to the value of v.

   The value of v is unchanged.

   The expression v.~T() also must be valid, and, for lvalue v, the
   expression &v must have the type T* or const T* and must evaluate to
   the address of v.
   (until C++11)

Notes

   Until C++11, classes that overloaded operator& were not
   CopyConstructible and thus were not usable in the standard library
   containers. This is a design decision in C++98 (instead of a defect,
   see LWG issue 390).

   Since C++11, the standard library uses std::addressof whenever the
   address of an object is needed.
   Extended content

   Being a CopyConstructible class implies std::is_copy_constructible but
   not vice versa since std::is_copy_constructible will only check for the
   ability to call the constructor with the correct arguments, and, e.g.,
   not a MoveConstructible requirement.
   Run this code
#include <type_traits>
#include <utility>

struct S
{
    S() = default;
    S(S&&) = delete;
    S(const S&) = default;
};
static_assert(std::is_copy_constructible_v<S>);

int main()
{
    S s1;

    // Class `S` doesn't satisfy MoveConstructible requirement,
    // hence doesn't satisfy CopyConstructible requirement
    [[maybe_unused]] S s2{std::move(s1)}; // ill-formed, use of deleted function
}

References

              Extended content
     * C++23 standard (ISO/IEC 14882:2023):

          + 16.4.4.2 Template argument requirements
            [utility.arg.requirements]

See also

   is_copy_constructibleis_trivially_copy_constructibleis_nothrow_copy_con
   structible
   (C++11)(C++11)(C++11)
   checks if a type has a copy constructor
   (class template)
   copy_constructible
   (C++20)
   specifies that an object of a type can be copy constructed and move
   constructed
   (concept)
   Retrieved from
   "https://en.cppreference.com/mwiki/index.php?title=cpp/named_req/CopyCo
   nstructible&oldid=170058"

Navigation

     * Online version
     * Offline version retrieved 2024-06-10 08:17.

     * This page was last modified on 3 March 2024, at 23:19.
     * This page has been accessed 145,188 times.
