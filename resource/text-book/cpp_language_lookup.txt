Name lookup

   From cppreference.com
   < cpp | language

   C++
   Compiler support
   Freestanding and hosted
   Language
   Standard library
   Standard library headers
   Named requirements
   Feature test macros (C++20)
   Language support library
   Concepts library (C++20)
   Metaprogramming library (C++11)
   Diagnostics library
   General utilities library
   Strings library
   Containers library
   Iterators library
   Ranges library (C++20)
   Algorithms library
   Numerics library
   Localizations library
   Input/output library
   Filesystem library (C++17)
   Regular expressions library (C++11)
   Concurrency support library (C++11)
   Technical specifications
   Symbols index
   External libraries

   C++ language
   General topics
   Preprocessor
   Comments
   Keywords
   Escape sequences
   Flow control
   Conditional execution statements
   if
   switch
   Iteration statements (loops)
   for
   range-for (C++11)
   while
   do-while
   Jump statements
   continue - break
   goto - return
   Functions
   Function declaration
   Lambda function expression
   inline specifier
   Dynamic exception specifications (until C++17*)
   noexcept specifier (C++11)
   Exceptions
   throw-expression
   try block
   handler
   Namespaces
   Namespace declaration
   Namespace aliases
   Types
   Fundamental types
   Enumeration types
   Function types
   Class/struct types
   Union types
   Specifiers
   const/volatile
   decltype (C++11)
   auto (C++11)
   constexpr (C++11)
   consteval (C++20)
   constinit (C++20)
   Storage duration specifiers
   Initialization
   Default-initialization
   Value-initialization
   Zero-initialization
   Copy-initialization
   Direct-initialization
   Aggregate initialization
   List-initialization (C++11)
   Constant initialization
   Reference initialization
   Expressions
   Value categories
   Order of evaluation
   Operators
   Operator precedence
   Alternative representations
   Literals
   Boolean - Integer - Floating-point
   Character - String - nullptr (C++11)
   User-defined (C++11)
   Utilities
   Attributes (C++11)
   Types
   typedef declaration
   Type alias declaration (C++11)
   Casts
   Implicit conversions
   static_cast
   const_cast
   Explicit conversions
   dynamic_cast
   reinterpret_cast
   Memory allocation
   new expression
   delete expression
   Classes
   Class declaration
   Constructors
   this pointer
   Access specifiers
   friend specifier
   Class-specific function properties
   Virtual function
   override specifier (C++11)
   final specifier (C++11)
   explicit (C++11)
   static
   Special member functions
   Default constructor
   Copy constructor
   Move constructor (C++11)
   Copy assignment
   Move assignment (C++11)
   Destructor
   Templates
   Class template
   Function template
   Template specialization
   Parameter packs (C++11)
   Miscellaneous
   Inline assembly
   History of C++

   Basic Concepts
   Comments
   ASCII
   Punctuation
   Names and identifiers
   Types
   Fundamental types
   Objects
   Scope
   Object lifetime
   Storage duration and linkage
   Definitions and ODR
   Name lookup
   Qualified name lookup
   Unqualified name lookup
   The as-if rule
   Undefined behavior
   Memory model
   Multi-threaded executions and data races (C++11)
   Character sets and encodings
   Phases of translation
   The main function
   Modules (C++20)

   Name lookup is the procedure by which a name, when encountered in a
   program, is associated with the declaration that introduced it.

   For example, to compile std::cout << std::endl;, the compiler performs:
     * unqualified name lookup for the name std, which finds the
       declaration of namespace std in the header <iostream>
     * qualified name lookup for the name cout, which finds a variable
       declaration in the namespace std
     * qualified name lookup for the name endl, which finds a function
       template declaration in the namespace std
     * both argument-dependent lookup for the name operator<<, which finds
       multiple function template declarations in the namespace std, and
       qualified name lookup for the name std::ostream::operator<<, which
       finds multiple member function declarations in class std::ostream.

   For function and function template names, name lookup can associate
   multiple declarations with the same name, and may obtain additional
   declarations from argument-dependent lookup. Template argument
   deduction may also apply, and the set of declarations is passed to
   overload resolution, which selects the declaration that will be used.
   Member access rules, if applicable, are considered only after name
   lookup and overload resolution.

   For all other names (variables, namespaces, classes, etc), name lookup
   can associate multiple declarations only if they declare the same
   entity, otherwise it must produce a single declaration in order for the
   program to compile. Lookup for a name in a scope finds all declarations
   of that name, with one exception, known as the "struct hack" or
   "type/non-type hiding": Within the same scope, some occurrences of a
   name may refer to a declaration of a class/struct/union/enum that is
   not a typedef, while all other occurrences of the same name either all
   refer to the same variable, non-static data member, or enumerator, or
   they all refer to possibly overloaded function or function template
   names. In this case, there is no error, but the type name is hidden
   from lookup (the code must use elaborated type specifier to access it).

Types of lookup

   If the name appears immediately to the right of the scope resolution
   operator :: or possibly after :: followed by the disambiguating keyword
   template, see
     * Qualified name lookup

   Otherwise, see
     * Unqualified name lookup

          + (which, for function names, includes Argument-dependent
            lookup)

Defect reports

   The following behavior-changing defect reports were applied
   retroactively to previously published C++ standards.
   DR Applied to Behavior as published Correct behavior
   CWG 2063 C++98 "struct hack" did not apply in class scope (breaks C
   compatibility) applied
   CWG 2218 C++98 lookup for non-function (template) names could not
   associate
   multiple declarations, even if they declare the same entity allowed

See also

     * Scope
     * Argument-dependent lookup
     * Template argument deduction
     * Overload resolution

   Retrieved from
   "https://en.cppreference.com/mwiki/index.php?title=cpp/language/lookup&
   oldid=145116"

Navigation

     * Online version
     * Offline version retrieved 2024-06-10 08:17.

     * This page was last modified on 17 November 2022, at 08:01.
     * This page has been accessed 208,471 times.
