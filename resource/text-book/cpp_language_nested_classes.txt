Nested classes

   From cppreference.com
   < cpp | language

   C++
   Compiler support
   Freestanding and hosted
   Language
   Standard library
   Standard library headers
   Named requirements
   Feature test macros (C++20)
   Language support library
   Concepts library (C++20)
   Metaprogramming library (C++11)
   Diagnostics library
   General utilities library
   Strings library
   Containers library
   Iterators library
   Ranges library (C++20)
   Algorithms library
   Numerics library
   Localizations library
   Input/output library
   Filesystem library (C++17)
   Regular expressions library (C++11)
   Concurrency support library (C++11)
   Technical specifications
   Symbols index
   External libraries

   C++ language
   General topics
   Preprocessor
   Comments
   Keywords
   Escape sequences
   Flow control
   Conditional execution statements
   if
   switch
   Iteration statements (loops)
   for
   range-for (C++11)
   while
   do-while
   Jump statements
   continue - break
   goto - return
   Functions
   Function declaration
   Lambda function expression
   inline specifier
   Dynamic exception specifications (until C++17*)
   noexcept specifier (C++11)
   Exceptions
   throw-expression
   try block
   handler
   Namespaces
   Namespace declaration
   Namespace aliases
   Types
   Fundamental types
   Enumeration types
   Function types
   Class/struct types
   Union types
   Specifiers
   const/volatile
   decltype (C++11)
   auto (C++11)
   constexpr (C++11)
   consteval (C++20)
   constinit (C++20)
   Storage duration specifiers
   Initialization
   Default-initialization
   Value-initialization
   Zero-initialization
   Copy-initialization
   Direct-initialization
   Aggregate initialization
   List-initialization (C++11)
   Constant initialization
   Reference initialization
   Expressions
   Value categories
   Order of evaluation
   Operators
   Operator precedence
   Alternative representations
   Literals
   Boolean - Integer - Floating-point
   Character - String - nullptr (C++11)
   User-defined (C++11)
   Utilities
   Attributes (C++11)
   Types
   typedef declaration
   Type alias declaration (C++11)
   Casts
   Implicit conversions
   static_cast
   const_cast
   Explicit conversions
   dynamic_cast
   reinterpret_cast
   Memory allocation
   new expression
   delete expression
   Classes
   Class declaration
   Constructors
   this pointer
   Access specifiers
   friend specifier
   Class-specific function properties
   Virtual function
   override specifier (C++11)
   final specifier (C++11)
   explicit (C++11)
   static
   Special member functions
   Default constructor
   Copy constructor
   Move constructor (C++11)
   Copy assignment
   Move assignment (C++11)
   Destructor
   Templates
   Class template
   Function template
   Template specialization
   Parameter packs (C++11)
   Miscellaneous
   Inline assembly
   History of C++

   Classes
   General
   Overview
   class/struct types
   union types
   Injected-class-name
   Members
   Data members
   Static members
   The this pointer
   Nested classes
   Member templates
   Bit-fields
   using-declarations
   Member functions
   Member access specifiers
   Constructors and member initializer lists
   Default member initializer (C++11)
   friend specifier
   explicit specifier
   Converting constructor
   Special member functions
   Default constructor
   Copy constructor
   Move constructor (C++11)
   Copy assignment operator
   Move assignment operator (C++11)
   Destructor
   Inheritance
   Base and derived classes
   Empty base optimization (EBO)
   Virtual member functions
   Pure virtual functions and abstract classes
   override specifier (C++11)
   final specifier (C++11)

   A declaration of a class/struct or union may appear within another
   class. Such declaration declares a nested class.

Explanation

   The name of the nested class exists in the scope of the enclosing
   class, and name lookup from a member function of a nested class visits
   the scope of the enclosing class after examining the scope of the
   nested class. Like any member of its enclosing class, the nested class
   has access to all names (private, protected, etc) to which the
   enclosing class has access, but it is otherwise independent and has no
   special access to the this pointer of the enclosing class. Declarations
   in a nested class can use any members of the enclosing class, following
   the usual usage rules for the non-static members.
int x, y; // globals
class enclose // enclosing class
{
    // note: private members
    int x;
    static int s;
public:
    struct inner // nested class
    {
        void f(int i)
        {
            x = i; // Error: can't write to non-static enclose::x without instan
ce
            int a = sizeof x; // Error until C++11,
                              // OK in C++11: operand of sizeof is unevaluated,
                              // this use of the non-static enclose::x is allowe
d.
            s = i;   // OK: can assign to the static enclose::s
            ::x = i; // OK: can assign to global x
            y = i;   // OK: can assign to global y
        }

        void g(enclose* p, int i)
        {
            p->x = i; // OK: assign to enclose::x
        }
    };
};

   Friend functions defined within a nested class have no special access
   to the members of the enclosing class even if lookup from the body of a
   member function that is defined within a nested class can find the
   private members of the enclosing class.

   Out-of-class definitions of the members of a nested class appear in the
   namespace of the enclosing class:
struct enclose
{
    struct inner
    {
        static int x;
        void f(int i);
    };
};

int enclose::inner::x = 1;       // definition
void enclose::inner::f(int i) {} // definition

   Nested classes can be forward-declared and later defined, either within
   the same enclosing class body, or outside of it:
class enclose
{
    class nested1;    // forward declaration
    class nested2;    // forward declaration
    class nested1 {}; // definition of nested class
};

class enclose::nested2 {}; // definition of nested class

   Nested class declarations obey member access specifiers, a private
   member class cannot be named outside the scope of the enclosing class,
   although objects of that class may be manipulated:
class enclose
{
    struct nested // private member
    {
        void g() {}
    };
public:
    static nested f() { return nested{}; }
};

int main()
{
    //enclose::nested n1 = enclose::f(); // error: 'nested' is private

    enclose::f().g();       // OK: does not name 'nested'
    auto n2 = enclose::f(); // OK: does not name 'nested'
    n2.g();
}

Defect reports

   The following behavior-changing defect reports were applied
   retroactively to previously published C++ standards.
   DR Applied to Behavior as published Correct behavior
   CWG 45 C++98 the members of a nested class cannot
   access the enclosing class and its friends they have the same access
   rights as
   other members of the enclosing class
   (also resolves CWG issues #8 and #10)

References

     * C++23 standard (ISO/IEC 14882:2023):

          + 11.4.12 Nested class declarations [class.nest]

     * C++20 standard (ISO/IEC 14882:2020):

          + 11.4.10 Nested class declarations [class.nest]

     * C++17 standard (ISO/IEC 14882:2017):

          + 12.2.5 Nested class declarations [class.nest]

     * C++14 standard (ISO/IEC 14882:2014):

          + 9.7 Nested class declarations [class.nest]

     * C++11 standard (ISO/IEC 14882:2011):

          + 9.7 Nested class declarations [class.nest]

     * C++98 standard (ISO/IEC 14882:1998):

          + 9.7 Nested class declarations [class.nest]

   Retrieved from
   "https://en.cppreference.com/mwiki/index.php?title=cpp/language/nested_
   types&oldid=151806"

Navigation

     * Online version
     * Offline version retrieved 2024-06-10 08:17.

     * This page was last modified on 17 May 2023, at 12:12.
     * This page has been accessed 543,166 times.
