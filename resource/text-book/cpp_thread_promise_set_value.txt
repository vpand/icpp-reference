std::promise<R>::set_value

   From cppreference.com
   < cpp | thread | promise

   C++
   Compiler support
   Freestanding and hosted
   Language
   Standard library
   Standard library headers
   Named requirements
   Feature test macros (C++20)
   Language support library
   Concepts library (C++20)
   Metaprogramming library (C++11)
   Diagnostics library
   General utilities library
   Strings library
   Containers library
   Iterators library
   Ranges library (C++20)
   Algorithms library
   Numerics library
   Localizations library
   Input/output library
   Filesystem library (C++17)
   Regular expressions library (C++11)
   Concurrency support library (C++11)
   Technical specifications
   Symbols index
   External libraries

   Concurrency support library
   Threads
   thread
   (C++11)
   jthread
   (C++20)
   stop_token
   (C++20)
   stop_source
   (C++20)
   stop_callback
   (C++20)
   hardware_destructive_interference_sizehardware_constructive_interferenc
   e_size
   (C++17)(C++17)
   this_thread namespace
   get_id
   (C++11)
   yield
   (C++11)
   sleep_for
   (C++11)
   sleep_until
   (C++11)
   Mutual exclusion
   mutex
   (C++11)
   recursive_mutex
   (C++11)
   shared_mutex
   (C++17)
   timed_mutex
   (C++11)
   recursive_timed_mutex
   (C++11)
   shared_timed_mutex
   (C++14)
   Generic lock management
   lock_guard
   (C++11)
   scoped_lock
   (C++17)
   unique_lock
   (C++11)
   shared_lock
   (C++14)
   defer_lock_ttry_to_lock_tadopt_lock_t
   (C++11)(C++11)(C++11)
   lock
   (C++11)
   try_lock
   (C++11)
   defer_locktry_to_lockadopt_lock
   (C++11)(C++11)(C++11)
   once_flag
   (C++11)
   call_once
   (C++11)
   Condition variables
   condition_variable
   (C++11)
   condition_variable_any
   (C++11)
   notify_all_at_thread_exit
   (C++11)
   cv_status
   (C++11)
   Semaphores
   counting_semaphorebinary_semaphore
   (C++20)(C++20)
   Latches and Barriers
   latch
   (C++20)
   barrier
   (C++20)
   Futures
   promise
   (C++11)
   future
   (C++11)
   shared_future
   (C++11)
   packaged_task
   (C++11)
   async
   (C++11)
   launch
   (C++11)
   future_status
   (C++11)
   future_error
   (C++11)
   future_category
   (C++11)
   future_errc
   (C++11)
   Safe Reclamation
   rcu_obj_base
   (C++26)
   rcu_domain
   (C++26)
   rcu_default_domain
   (C++26)
   rcu_synchronize
   (C++26)
   rcu_barrier
   (C++26)
   rcu_retire
   (C++26)
   Hazard Pointers
   hazard_pointer_obj_base
   (C++26)
   hazard_pointer
   (C++26)
   make_hazard_pointer
   (C++26)
   Atomic types
   atomic
   (C++11)
   atomic_ref
   (C++20)
   atomic_flag
   (C++11)
   Initialization of atomic types
   atomic_init
   (C++11)(deprecated in C++20)
   ATOMIC_VAR_INIT
   (C++11)(deprecated in C++20)
   ATOMIC_FLAG_INIT
   (C++11)
   Memory ordering
   memory_order
   (C++11)
   kill_dependency
   (C++11)
   atomic_thread_fence
   (C++11)
   atomic_signal_fence
   (C++11)
   Free functions for atomic operations
   atomic_storeatomic_store_explicit
   (C++11)(C++11)
   atomic_loadatomic_load_explicit
   (C++11)(C++11)
   atomic_exchangeatomic_exchange_explicit
   (C++11)(C++11)
   atomic_compare_exchange_weakatomic_compare_exchange_weak_explicitatomic
   _compare_exchange_strongatomic_compare_exchange_strong_explicit
   (C++11)(C++11)(C++11)(C++11)
   atomic_fetch_addatomic_fetch_add_explicit
   (C++11)(C++11)
   atomic_fetch_subatomic_fetch_sub_explicit
   (C++11)(C++11)
   atomic_fetch_andatomic_fetch_and_explicit
   (C++11)(C++11)
   atomic_fetch_oratomic_fetch_or_explicit
   (C++11)(C++11)
   atomic_fetch_xoratomic_fetch_xor_explicit
   (C++11)(C++11)
   atomic_fetch_maxatomic_fetch_max_explicit
   (C++26)(C++26)
   atomic_fetch_minatomic_fetch_min_explicit
   (C++26)(C++26)
   atomic_is_lock_free
   (C++11)
   atomic_waitatomic_wait_explicit
   (C++20)(C++20)
   atomic_notify_one
   (C++20)
   atomic_notify_all
   (C++20)
   Free functions for atomic flags
   atomic_flag_test_and_setatomic_flag_test_and_set_explicit
   (C++11)(C++11)
   atomic_flag_clearatomic_flag_clear_explicit
   (C++11)(C++11)
   atomic_flag_testatomic_flag_test_explicit
   (C++20)(C++20)
   atomic_flag_waitatomic_flag_wait_explicit
   (C++20)(C++20)
   atomic_flag_notify_one
   (C++20)
   atomic_flag_notify_all
   (C++20)

   std::promise
   Member functions
   promise::promise
   promise::~promise
   promise::operator=
   promise::swap
   Getting the result
   promise::get_future
   Setting the result
   promise::set_value
   promise::set_value_at_thread_exit
   promise::set_exception
   promise::set_exception_at_thread_exit
   Non-member Functions
   swap(std::promise)
   Helper Classes
   uses_allocator<std::promise>

   Main template
   void set_value( const R& value );
   (1)                              (since C++11)
   void set_value( R&& value );
   (2)                              (since C++11)
   std::promise<R&> specializations
   void set_value( R& value );
   (3)                              (since C++11)
   std::promise<void> specialization
   void set_value();
   (4)                              (since C++11)
   1-3) Atomically stores value into the shared state and makes the state
   ready.
   4) Makes the state ready.

   The operation behaves as though set_value, set_exception,
   set_value_at_thread_exit, and set_exception_at_thread_exit acquire a
   single mutex associated with the promise object while updating the
   promise object.

   Calls to this function do not introduce data races with calls to
   get_future (therefore they need not synchronize with each other).

Parameters

   value - value to store in the shared state

Return value

   (none)

Exceptions

   std::future_error on the following conditions:
     * *this has no shared state. The error code is set to no_state.
     * The shared state already stores a value or exception. The error
       code is set to promise_already_satisfied.

   Additionally:
   1) Any exception thrown by the constructor selected to copy an object
   of type R.
   2) Any exception thrown by the constructor selected to move an object
   of type R.

Example

   This example shows how std::promise<void> can be used as signals
   between threads.
   Run this code
#include <algorithm>
#include <cctype>
#include <chrono>
#include <future>
#include <iostream>
#include <iterator>
#include <sstream>
#include <thread>
#include <vector>

using namespace std::chrono_literals;

int main()
{
    std::istringstream iss_numbers{"3 4 1 42 23 -23 93 2 -289 93"};
    std::istringstream iss_letters{" a 23 b,e a2 k k?a;si,ksa c"};

    std::vector<int> numbers;
    std::vector<char> letters;
    std::promise<void> numbers_promise, letters_promise;

    auto numbers_ready = numbers_promise.get_future();
    auto letter_ready = letters_promise.get_future();

    std::thread value_reader([&]
    {
        // I/O operations
        std::copy(std::istream_iterator<int>{iss_numbers},
                  std::istream_iterator<int>{},
                  std::back_inserter(numbers));

        // notify for numbers
        numbers_promise.set_value();

        std::copy_if(std::istreambuf_iterator<char>{iss_letters},
                     std::istreambuf_iterator<char>{},
                     std::back_inserter(letters),
                     ::isalpha);

        // notify for letters
        letters_promise.set_value();
    });


    numbers_ready.wait();

    std::sort(numbers.begin(), numbers.end());

    if (letter_ready.wait_for(1s) == std::future_status::timeout)
    {
        // output the numbers while letters are being obtained
        for (int num : numbers)
            std::cout << num << ' ';
        numbers.clear(); // numbers were already printed
    }

    letter_ready.wait();
    std::sort(letters.begin(), letters.end());

    // does nothing if numbers were already printed
    for (int num : numbers)
        std::cout << num << ' ';
    std::cout << '\n';

    for (char let : letters)
        std::cout << let << ' ';
    std::cout << '\n';

    value_reader.join();
}

   Output:
-289 -23 1 2 3 4 23 42 93 93
a a a a b c e i k k k s s

Defect reports

   The following behavior-changing defect reports were applied
   retroactively to previously published C++ standards.
   DR Applied to Behavior as published Correct behavior
   LWG 2098 C++11 overloads (1,2) could only throw the
   exceptions thrown by the copy/move
   constructor of R respectively they can throw the exceptions thrown
   by the actual constructor selected
   to copy/move an object of type R

See also

   set_value_at_thread_exit
   sets the result to specific value while delivering the notification
   only at thread exit
   (public member function)
   set_exception
   sets the result to indicate an exception
   (public member function)
   Retrieved from
   "https://en.cppreference.com/mwiki/index.php?title=cpp/thread/promise/s
   et_value&oldid=169933"

Navigation

     * Online version
     * Offline version retrieved 2024-06-10 08:17.

     * This page was last modified on 25 February 2024, at 22:52.
     * This page has been accessed 122,626 times.
